var documenterSearchIndex = {"docs":
[{"location":"tutorial/helmholtz/#Helmholtz-equation-(FE)","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"","category":"section"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"This tutorial shows how to solve the Helmholtz eigen problem with a finite-element approach using Bcube.","category":"page"},{"location":"tutorial/helmholtz/#Theory","page":"Helmholtz equation (FE)","title":"Theory","text":"","category":"section"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"We consider the following Helmholtz equation, representing for instance the acoustic wave propagation with Neuman boundary condition(s):","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"begincases\n  Delta u + omega^2 u = 0 \n  dfracpartial upartial n = 0 textrm  on   Gamma\nendcases","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"An analytic solution of this equation can be obtained: for a rectangular domain Omega = 0L_x times 0L_y,","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"u(xy) = cos left( frack_x piL_x x right) cos left( frack_y piL_y y right) mathrmwith k_xk_y in mathbbN","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"with omega^2 = pi^2 left( dfrack_x^2L_x^2 + dfrack_y^2L_y^2 right)","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Now, both the finite-element method and the discontinuous Galerkin method requires to write the weak form of the problem:","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"int_Omega (Delta u Delta v + omega^2u)v mathrmdOmega = 0","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"- int_Omega nabla u cdot nabla v mathrmdOmega\n+ underbraceleft (nabla u cdot n) v right_Gamma_=0 + omega^2 int_Omega u v mathrmd Omega = 0","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"int_Omega nabla u cdot nabla v mathrmd Omega = omega^2 int_Omega u v mathrmd Omega","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Introducing to bilinear forms a(uv) and b(uv) for respectively the left and right side terms, this equation can be written","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"a(uv) = omega^2 b(uv)","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"This is actually a generalized eigenvalue problem which can be written:","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"A u = alpha B u","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"where","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"A u = int_Omega nabla u cdot nabla v mathrmd Omega B u = int_Omega u v mathrmd Omega alpha = omega^2","category":"page"},{"location":"tutorial/helmholtz/#Uncommented-code","page":"Helmholtz equation (FE)","title":"Uncommented code","text":"","category":"section"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"The code below solves the described Helmholtz eigen problem. The code with detailed comments is provided in the next section.","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"\nusing Bcube\nusing LinearAlgebra\n\nmesh = rectangle_mesh(21, 21)\n\ndegree = 1\nfs = FunctionSpace(:Lagrange, degree)\n\nU = TrialFESpace(fs, mesh)\nV = TestFESpace(U)\n\ndomain = CellDomain(mesh)\n\ndΩ = Measure(domain, Quadrature(2 * degree + 1))\n\na(u, v) = ∫(∇(u) ⋅ ∇(v))dΩ\nb(u, v) = ∫(u ⋅ v)dΩ\n\nA = assemble_bilinear(a, U, V)\nB = assemble_bilinear(b, U, V)\n\nvp, vecp = eigen(Matrix(A), Matrix(B))\n\n@show sqrt.(abs.(vp[3:8]))\n","category":"page"},{"location":"tutorial/helmholtz/#Commented-code","page":"Helmholtz equation (FE)","title":"Commented code","text":"","category":"section"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Load the necessary packages","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"using Bcube\nusing LinearAlgebra","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Mesh a 2D rectangular domain with quads.","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"mesh = rectangle_mesh(21, 21)","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Next, create the function space that will be used for the trial and test spaces. The Lagrange polynomial space is used here. The degree is set to 1.","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"degree = 1\nfs = FunctionSpace(:Lagrange, degree)","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"The trial space is created from the function space and the mesh. By default, a scalar \"continuous\" FESpace is created. For \"discontinuous\" (\"DG\") example, check out the linear transport tutorial.","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"U = TrialFESpace(fs, mesh)\nV = TestFESpace(U)","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Then, define the geometrical dommain on which the operators will apply. For this finite-element example, we only need a CellDomain (no FaceDomain).","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"domain = CellDomain(mesh)","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Now, integrating on a domain necessitates a \"measure\", basically a quadrature of given degree.","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"dΩ = Measure(domain, Quadrature(2 * degree + 1))","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"The definition of the two bilinear forms is quite natural. Note that these definitions are lazy, no computation is done at this step : the computations will be triggered by the assembly.","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"a(u, v) = ∫(∇(u) ⋅ ∇(v))dΩ\nb(u, v) = ∫(u ⋅ v)dΩ","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"To obtain the two sparse matrices corresponding to the discretisation of these bilinear forms, simply call the assemble_bilinear function, providing the trial and test spaces.","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"A = assemble_bilinear(a, U, V)\nB = assemble_bilinear(b, U, V)","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Compute eigen-values and vectors : we convert to dense matrix to avoid importing additionnal packages, but it is quite easy to solve it in a \"sparse way\".","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"vp, vecp = eigen(Matrix(A), Matrix(B))","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Display the \"first\" five eigenvalues:","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"@show sqrt.(abs.(vp[3:8]))","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"Now we can export the solution (the eigenvectors) at nodes (or, eventually, at centers) of the mesh for several eigenvalues. We will restrict to the first 20 eigenvectors. To do so, we will create a FEFunction for each eigenvector. This FEFunction can then be evaluated on the mesh centers, nodes, etc.","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"nvecs = min(20, get_ndofs(U))\neigenvectors = map(ivec -> FEFunction(U, vecp[:, ivec]), 1:nvecs)","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"To write a VTK file, we need to build a dictionnary with the variable name and the values. By default, write_file writes the solution on mesh vertices.","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"using BcubeVTK\noutputvtk = \"../../myout/helmholtz/rectangle_mesh.pvd\"\ndict_vars = Dict(\"u_$i\" => eigenvectors[i] for i in 1:nvecs)\nwrite_file(joinpath(@__DIR__, outputvtk), mesh, dict_vars)","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"And here is the eigenvector corresponding to the 4th eigenvalue: (Image: )","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"","category":"page"},{"location":"tutorial/helmholtz/","page":"Helmholtz equation (FE)","title":"Helmholtz equation (FE)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/phase_field_supercooled/#Phase-field-model-solidification-of-a-liquid-in-supercooled-state","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"","category":"section"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"In this tutorial, a coupled system of two unsteady equations is solved using finite elements and an imex time scheme. This tutorial doesn't introduce MultiFESpace, check the \"euler\" example for this. Warning : this file is currently quite long to run (a few minutes).","category":"page"},{"location":"tutorial/phase_field_supercooled/#Theory","page":"Phase field model - solidification of a liquid in supercooled state","title":"Theory","text":"","category":"section"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"This case is taken from: Kobayashi, R. (1993). Modeling and numerical simulations of dendritic crystal growth. Physica D: Nonlinear Phenomena, 63(3-4), 410-423. In particular, the variables of the problem are denoted in the same way (p for the phase indicator and T for temperature). Consider a rectangular domain Omega = 0 L_x times 0 L_y on which we wish to solve the following equations:","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"  tau partial_t p = epsilon^2 Delta p + p (1-p)(p - frac12 + m(T))","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"  partial_t T = Delta T + K partial_t p","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"where m(T) = fracalphapi atan left gamma (T_e - T) right. This set of equations represents the solidification of a liquid in a supercooled state. Here T is a dimensionless temperature and p is the solid volume fraction. Lagrange finite elements are used to discretize both equations. Time marching is performed with a forward Euler scheme for the first equation and a backward Euler scheme for the second one.","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"To initiate the solidification process, a Dirichlet boundary condition (p=1,T=1) is applied at x=0 (\"West\" boundary).","category":"page"},{"location":"tutorial/phase_field_supercooled/#Code","page":"Phase field model - solidification of a liquid in supercooled state","title":"Code","text":"","category":"section"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Load the necessary packages","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"using Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing LinearAlgebra\nusing Random\n\nRandom.seed!(1234) # to obtain reproductible results","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Define some physical and numerical constants, as well as the g function appearing in the problem definition.","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"const ε = 0.01\nconst τ = 0.0003\nconst α = 0.9\nconst γ = 10.0\nconst K = 1.6\nconst Te = 1.0\nconst β = 0.0 # noise amplitude, original value : 0.01\nconst Δt = 0.0001 # time step\nconst totalTime = 1.0 # original value : 1\nconst nout = 50 # Number of iterations to skip before writing file\nconst degree = 1 # function space degree\nconst lx = 3.0\nconst ly = 1.0\nconst nx = 100\nconst ny = 20\nconst out_dir = joinpath(@__DIR__, \"../../myout/phase_field_supercooled\") # output directory","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Read the mesh using gmsh","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"const mesh_path = joinpath(@__DIR__, \"../../input/mesh/domainPhaseField_tri.msh\")","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Here we define the main algorithm in a function to avoid performance penalty (see Performance Tips)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"function main()","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"read the mesh file","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    mesh = read_mesh(mesh_path)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Noise function : random between [-1/2,1/2]","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    χ = MeshCellData(rand(ncells(mesh)) .- 0.5)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Build the function space and the FE Spaces. The two unknowns will share the same FE spaces for this tutorial. Note the way we specify the Dirichlet condition in the definition of U.","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    fs = FunctionSpace(:Lagrange, degree)\n    U = TrialFESpace(fs, mesh, Dict(\"West\" => (x, t) -> 1.0))\n    V = TestFESpace(U)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Build FE functions","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    ϕ = FEFunction(U)\n    T = FEFunction(U)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Define measures for cell integration","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    dΩ = Measure(CellDomain(mesh), 2 * degree + 1)\n\n    g(T) = (α / π) * atan(γ * (Te - T))","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Define bilinear and linear forms. As the linear form is assembled at each step, we use the composition operator to exploit the full performance of Bcube.","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    a(u, v) = ∫(∇(u) ⋅ ∇(v))dΩ\n    m(u, v) = ∫(u ⋅ v)dΩ\n    f_l(ϕ, T, χ, v) = v * ϕ * (1.0 - ϕ) * (ϕ - 0.5 + g(T) + β * χ)\n    l(v) = ∫(f_l ∘ (ϕ, T, χ, v))dΩ","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Assemble the two constant matrices","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    A = assemble_bilinear(a, U, V)\n    M = assemble_bilinear(m, U, V)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Create iterative matrices","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    C_ϕ = M + Δt / τ * ε^2 * A\n    C_T = M + Δt * A","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Apply Dirichlet conditions. For this example, we don't use a lifting method to impose the Dirichlet, but d is used to initialize the solution.","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    d = assemble_dirichlet_vector(U, V, mesh)\n    d = collect(d) # SparseVector -> Vector\n    apply_dirichlet_to_matrix!((C_ϕ, C_T), U, V, mesh)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Init solution and write it to a VTK file","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    set_dof_values!(ϕ, d)\n    set_dof_values!(T, d)\n\n    filepath = joinpath(out_dir, \"result_phaseField_imex_1space.pvd\")\n    dict_vars = Dict(\"Temperature\" => T, \"Phi\" => ϕ)\n    write_file(filepath, mesh, dict_vars, 0, 0.0)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Factorize and allocate some vectors to increase performance","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    C_ϕ = factorize(C_ϕ)\n    C_T = factorize(C_T)\n    L = zero(d)\n    rhs = zero(d)\n    ϕ_new = zero(d)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"Time loop (imex time integration)","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"    t = 0.0\n    itime = 0\n    while t <= totalTime\n        t += Δt\n        itime += 1\n        @show t, totalTime\n\n        # Integrate equation on ϕ\n        L .= 0.0 # reset L\n        assemble_linear!(L, l, V)\n        rhs .= M * get_dof_values(ϕ) .+ (Δt / τ) .* L\n        apply_dirichlet_to_vector!(rhs, U, V, mesh)\n        ϕ_new .= C_ϕ \\ rhs\n\n        # Integrate equation on T\n        rhs .= M * (get_dof_values(T) .+ K .* (ϕ_new .- get_dof_values(ϕ)))\n        apply_dirichlet_to_vector!(rhs, U, V, mesh)\n\n        # Update solution\n        set_dof_values!(ϕ, ϕ_new)\n        set_dof_values!(T, C_T \\ rhs)\n\n        # write solution in vtk format\n        if itime % nout == 0\n            write_file(filepath, mesh, dict_vars, itime, t; collection_append = true)\n        end\n    end\nend","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"run simulation","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"main()","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"And here is an animation of the result: (Image: )","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"","category":"page"},{"location":"tutorial/phase_field_supercooled/","page":"Phase field model - solidification of a liquid in supercooled state","title":"Phase field model - solidification of a liquid in supercooled state","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example/stokes_flow/#Stokes-flow-example-(FE-with-Taylor-Hood-elements)","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"","category":"section"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"This example shows how to solve the equations of motion for Stokes flow with mathbbP2-mathbbP1 (Taylor-Hood) elements using Bcube.","category":"page"},{"location":"example/stokes_flow/#Steady-case-Moffat-vortices","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Steady case - Moffat vortices","text":"","category":"section"},{"location":"example/stokes_flow/#Theory","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Theory","text":"","category":"section"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Let's first consider a Stokes flow within a wedge of angle theta = 28^circ and height H=1m. A velocity of 1ms is imposed on the top boundary (the lid) as well as zero pressure. On the left and right edges a no-slip boundary condition is applied.","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"(Image: )","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"The set of equations are:","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"begincases\n  0 = nabla cdot left( -p mathbbI + mu nabla u right) + f  textrm  in  Omega \n  nabla cdot u = 0 textrm  in  Omega  \n  u = (00)  textrm  on  Gamma_L cup Gamma_R \n  u = (10) textrm and  p=0 textrm  on  Gamma_T\nendcases","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Density rho is taken equal to 1400kgm^-3 and dynamic viscosity mu equal to 14 Pas. The Reynolds number based on the height of the wedge is therefore equal to 1000. The weak form of this problem is given by:","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"begincases\n  textrm Find  u in V textrm and  p in Q textrm such that  forall v in V  forall q in Q\n  int_Omega left( mu nabla u  nabla v - p nabla cdot v right)  dx  = int_Omega f cdot v  dx  \n  int_Omega q nabla cdot u dx  = 0\nendcases","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"where V and Q are suitable function spaces. This can be recast in \"mixed\" formalism:","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"begincases\n  textrm Find  (up) in W=V times Q  textrm such that  forall (vq) in W\n  a((up)(vq)) = l((vq))\nendcases","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"where a((up)(vq)) = int_Omega left( mu nabla u  nabla v - p nabla cdot v +q nabla cdot u right) dx and l((vq))=int_Omega f cdot v  dx","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Taylor-Hood (mathbbP2-mathbbP1) elements are used to discretize the weak form of the problem which leads to the linear system:","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"beginbmatrix\n A  B^T \n B  0\nendbmatrix\nbeginbmatrix\nU \nP\nendbmatrix\n= L","category":"page"},{"location":"example/stokes_flow/#Commented-code","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Commented code","text":"","category":"section"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"import necessary packages","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"using Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing LinearAlgebra\nusing StaticArrays\nusing SpecialFunctions","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Function space: P2 for velocity and P1 for pressure","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"const fspace = :Lagrange\nconst degree_u = 2\nconst degquad = 2 * degree_u + 1\nconst degree_p = 1","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Material parameters","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"const ρ = 1400.0\nconst μ = 14.0\nconst ν = μ / ρ","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Parameters for the oscillating plate case","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"const f = 1.0\nconst k = sqrt(π * f / ν)\n\nconst Δt = 1.0e-3\nconst finalTime = 2.0\n\nconst outputpath = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"myout\", \"stokes\")\nmkpath(outputpath)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Function that runs the steady case:","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"function run_steady()","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Read 2D mesh","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    mesh_path =\n        joinpath(@__DIR__, \"..\", \"..\", \"..\", \"input\", \"mesh\", \"domainTriangle_tri.msh\")\n    mesh = read_mesh(mesh_path)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Definition of trial and test function spaces (with associated Dirichlet boundary conditions)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    fsu = FunctionSpace(fspace, degree_u)\n    U_vel = TrialFESpace(\n        fsu,\n        mesh,\n        Dict(\n            \"edge_right\" => SA[0.0, 0.0],\n            \"edge_left\" => SA[0.0, 0.0],\n            \"edge_top\" => SA[1.0, 0.0],\n        );\n        size = 2,\n    )\n    V_vel = TestFESpace(U_vel)\n\n    fsp = FunctionSpace(fspace, degree_p)\n    U_pre = TrialFESpace(fsp, mesh, Dict(\"edge_top\" => SA[0.0]); size = 1)\n    V_pre = TestFESpace(U_pre)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Define MultiFESpace (mixed formalism)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    U = MultiFESpace(U_vel, U_pre)\n    V = MultiFESpace(V_vel, V_pre)\n\n    velocity = FEFunction(U_vel)\n    pressure = FEFunction(U_pre)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Define measures for cell","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    dΩ = Measure(CellDomain(mesh), degquad)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"volume force is equal to zero","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    f = PhysicalFunction(x -> SA[0.0, 0.0])","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"definition of bilinear and linear forms","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    a((u, p), (v, q)) = ∫(μ * ∇(u) ⊡ ∇(v) - tr(∇(v)) * p + tr(∇(u)) * q)dΩ\n    l((v, q)) = ∫(f ⋅ v)dΩ","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"assemble matrix and RHS","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    A = assemble_bilinear(a, U, V)\n    L = assemble_linear(l, V)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"build Dirichlet vector to apply lift","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    Wd = Bcube.assemble_dirichlet_vector(U, V, mesh)\n    Wd = collect(Wd) # SparseVector -> Vector","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Apply lift","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    L = L - A * Wd","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Apply homogeneous dirichlet condition","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    Bcube.apply_homogeneous_dirichlet_to_vector!(L, U, V, mesh)\n    Bcube.apply_dirichlet_to_matrix!(A, U, V, mesh)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Solve linear system","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    sol = A \\ L\n\n    sol = sol .+ Wd\n\n    ϕ = FEFunction(V, sol)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Write solution","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    velocity, pressure = ϕ\n\n    vars = Dict(\"Velocity\" => velocity, \"Pressure\" => pressure)\n    write_file(joinpath(outputpath, \"output_steady.pvd\"), mesh, vars)\nend","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"The obtained solution captures the Moffat vortices topology of the flow (Image: )","category":"page"},{"location":"example/stokes_flow/#Unsteady-case-oscillating-plate","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Unsteady case - oscillating plate","text":"","category":"section"},{"location":"example/stokes_flow/#Theory-2","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Theory","text":"","category":"section"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Let's now consider a Stokes flow over an oscillating flat plate of length 01m and height 05m. An oscillating velocity (sin(2pi f t)0) is imposed on the bottom boundary as well as zero pressure. On all the other boundaries a \"do nothing\" condition is applied: -pn + mu fracpartial upartial n = 0. The set of equations are:","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"begincases\n  rho fracpartial upartial t = nabla cdot left( -p mathbbI + mu nabla u right) + f  textrm  in  Omega \n  nabla cdot u = 0 textrm  in  Omega  \n  u = (00)  textrm  on  Gamma_L cup Gamma_R \n  u = (10) textrm and  p=0 textrm  on  Gamma_T\nendcases","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"The weak form of this problem is given by:","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"begincases\n  textrm Find  (up) in W=V times Q  textrm such that  forall (vq) in W\n  m((up)(vq))+a((up)(vq)) = l((vq))\nendcases","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"where m((up)(vq)) = int_Omega rho u cdot v  dx and l((vq))=int_Omega f cdot v  dx","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Taylor-Hood (mathbbP2-mathbbP1) elements are used to discretize the weak form of the problem which leads to the linear system:","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"beginbmatrix\n M  0 \n 0  0\nendbmatrix\nbeginbmatrix\ndotU \ndotP\nendbmatrix +\nbeginbmatrix\n A  B^T \n B  0\nendbmatrix\nbeginbmatrix\nU \nP\nendbmatrix\n= L","category":"page"},{"location":"example/stokes_flow/#Commented-code-2","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Commented code","text":"","category":"section"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Reference solution for unsteady case (Panton, R. L. (2013). Incompressible Flow, 4th edition, pages 228-236) This solution is valid for a semi-infinite domain.","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"function reference_solution(t, x)\n    Uₛ = exp(-k * x[2]) * sin(2.0 * π * f * t - k * x[2])\n    T = 2.0 * π * f * t\n    Y = x[2] / sqrt(ν / (2.0 * π * f))\n    C = 1.0 - im\n    Uₜ = imag(\n        0.5 *\n        exp(-im * T - C * Y / sqrt(2)) *\n        erfc(sqrt(0.5 * T) * (C - Y / (T * sqrt(2)))) -\n        0.5 *\n        exp(-im * T + C * Y / sqrt(2)) *\n        erfc(sqrt(0.5 * T) * (C + Y / (T * sqrt(2)))),\n    )\n    return Uₛ + Uₜ\nend","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Function that runs the unsteady case:","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"function run_unsteady()","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Generate 2D mesh","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    mesh = rectangle_mesh(\n        11,\n        51;\n        type = :quad,\n        xmin = 0.0,\n        xmax = 1.0e-1,\n        ymin = 0.0,\n        ymax = 5.0e-1,\n        order = 1,\n        bnd_names = (\"Left\", \"Right\", \"South\", \"North\"),\n    )","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Definition of trial and test function spaces (with associated Dirichlet boundary conditions)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    fsu = FunctionSpace(fspace, degree_u)\n    U_vel = TrialFESpace(\n        fsu,\n        mesh,\n        Dict(\"South\" => (x, t) -> SA[sin(2.0 * π * f * t), 0.0]);\n        size = 2,\n    )\n    V_vel = TestFESpace(U_vel)\n\n    fsp = FunctionSpace(fspace, degree_p)\n    U_pre = TrialFESpace(fsp, mesh, Dict(\"South\" => SA[0.0]); size = 1)\n    V_pre = TestFESpace(U_pre)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Define MultiFESpace (mixed formalism)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    U = MultiFESpace(U_vel, U_pre)\n    V = MultiFESpace(V_vel, V_pre)\n\n    velocity = FEFunction(U_vel)\n    pressure = FEFunction(U_pre)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Define measures for cell","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    dΩ = Measure(CellDomain(mesh), degquad)\n\n    fv = PhysicalFunction(x -> SA[0.0, 0.0])","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"definition of bilinear and linear forms","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    m((u, p), (v, q)) = ∫(ρ * u ⋅ v)dΩ\n    a((u, p), (v, q)) = ∫(μ * ∇(u) ⊡ ∇(v) - tr(∇(v)) * p + tr(∇(u)) * q)dΩ\n    l((v, q)) = ∫(fv ⋅ v)dΩ","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Assemble matrices and factorize","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    M = assemble_bilinear(m, U, V)\n    A = assemble_bilinear(a, U, V)\n    L = assemble_linear(l, V)\n\n    A0 = copy(A)\n\n    Bcube.apply_dirichlet_to_matrix!(A, U, V, mesh)\n    Bcube.apply_dirichlet_to_matrix!(M, U, V, mesh)\n\n    f_Mtime = factorize(M .+ Δt * A)\n\n    ϕ = FEFunction(V)\n\n    velocity_ref(t) = PhysicalFunction(x -> SA[reference_solution(t, x), 0.0])","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Write initial solution","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    filepath = joinpath(outputpath, \"output_unsteady.pvd\")\n    err = velocity - velocity_ref(0.0)\n    vars = Dict(\n        \"Velocity\" => velocity,\n        \"Velocity_ref\" => velocity_ref(0.0),\n        \"error\" => err,\n        \"Pressure\" => pressure,\n    )\n    write_file(filepath, mesh, vars, 0, 0.0; collection_append = false)","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"Time loop","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"    time = 0.0\n    itime = 0\n    sol = zero(L)\n\n    while time <= finalTime\n        time += Δt\n        itime += 1\n\n        println(\"Time stepping : time = \", time, \" / \", finalTime)\n\n        Wd = Bcube.assemble_dirichlet_vector(U, V, mesh, time)\n        Wd = collect(Wd) # SparseVector -> Vector\n\n        # Apply lift\n        L = -A0 * Wd\n\n        # Apply homogeneous dirichlet condition\n        Bcube.apply_homogeneous_dirichlet_to_vector!(L, U, V, mesh)\n\n        # Solve time step\n        sol = f_Mtime \\ (Δt * L + M * sol)\n\n        # Write results\n        if itime % 10 == 0\n            set_dof_values!(ϕ, sol .+ Wd)\n            velocity, pressure = ϕ\n\n            err = velocity - velocity_ref(time)\n\n            vars = Dict(\n                \"Velocity\" => velocity,\n                \"Velocity_ref\" => velocity_ref(time),\n                \"error\" => err,\n                \"Pressure\" => pressure,\n            )\n            write_file(filepath, mesh, vars, itime, time; collection_append = true)\n        end\n    end\nend","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"The obtained solution compares well with the reference solution (Image: )","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"println(\"\")\nprintln(\"-------------------------------\")\nprintln(\"----- Running steady case -----\")\nrun_steady()\nprintln(\"-------------------------------\")\nprintln(\"\")\nprintln(\"---------------------------------\")\nprintln(\"----- Running unsteady case -----\")\nrun_unsteady()\nprintln(\"---------------------------------\")\nprintln(\"\")\n","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"","category":"page"},{"location":"example/stokes_flow/","page":"Stokes flow example (FE with Taylor-Hood elements)","title":"Stokes flow example (FE with Taylor-Hood elements)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example/incompressible_navier_stokes/#Incompressible-Navier-Stokes-(FEM)-flow-around-a-cylinder","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"","category":"section"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"In this example, the laminar flow around a cylinder is simulated by solving the incompressible Navier-Stokes equations. The equations are discretized and solved using two methods, the projection method and the \"mixed form\" method. This tutorial is based on a DFG Benchmark and is also an example in Ferrite.jl.","category":"page"},{"location":"example/incompressible_navier_stokes/#Description-of-the-case","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Description of the case","text":"","category":"section"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"The simulation domain consists in a channel bounded above and below by two walls and within which a cylinder is placed. The geometrical parameters of the case are shown in the Figure below.","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"(Image: )","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"The flow around the cylinder is governed by the incompressible Navier-Stokes equations (here rho=1):","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"  partial_t u + u cdot nabla u = - nabla p + nu Delta u","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"  nabla cdot u = 0","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"To discretize the equations mathbbP_2-mathbbP_1 elements are used (Taylor-Hood).","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"No-slip boundary conditions are applied on all walls. The inlet is given by an imposed parabolic velocity profile which is ramped up in time:","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"  u(txy) = u_in(t) times left( 4  y (041-y)041^2  0 right)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"where u_in(t) = textrmclamp(t0015).","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"At the outlet, p=0 is imposed when using the projection method and a \"do-nothing\" (-pn + nu nabla u cdot n = 0) condition is applied when using the \"mixed form\" method.","category":"page"},{"location":"example/incompressible_navier_stokes/#Code","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Code","text":"","category":"section"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Load the necessary packages","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"const dir = string(@__DIR__, \"/\") # bcube/example dir\nusing Bcube\nusing LinearAlgebra\nusing BcubeVTK\nusing BcubeGmsh\nusing StaticArrays","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Function space (here we shall use Taylor-Hood P2-P1 elements) and quadrature degree.","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"const fspace = :Lagrange\nconst degree_u = 2\nconst degquad = 2 * degree_u + 1\nconst degree_p = 1","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Input and output paths","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"const outputpath = joinpath(dir, \"..\", \"..\", \"..\", \"myout\", \"navier_stokes/\")\nconst meshpath = joinpath(dir, \"../../../input/mesh/cylinder_navier_stokes_tri.msh\")\nmkpath(outputpath)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Kinematic viscosity","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"const ν = 0.001","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Time step and simulation time","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"const Δt = 1.0e-3\nconst finalTime = 6.0","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Function that defines the inlet velocity profile","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"function inlet_velocity(x, t)\n    SA[4.0 * clamp(t, 0.0, 1.5) * x[2] * (0.41 - x[2]) / (0.41 * 0.41), 0.0]\nend","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Function that solves the problem using the projection method","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"function run_unsteady_projection_method()","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Read mesh","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    mesh = read_mesh(meshpath)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Definition of trial and test function spaces (with associated Dirichlet boundary conditions)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    fsu = FunctionSpace(fspace, degree_u)\n    U_vel = TrialFESpace(\n        fsu,\n        mesh,\n        Dict(\n            \"left\" => inlet_velocity,\n            \"top\" => SA[0.0, 0.0],\n            \"bottom\" => SA[0.0, 0.0],\n            \"cylinder\" => SA[0.0, 0.0],\n        ); #\n        size = 2,\n    )\n    V_vel = TestFESpace(U_vel)\n\n    fsp = FunctionSpace(fspace, degree_p)\n    U_pre = TrialFESpace(fsp, mesh, Dict(\"right\" => SA[0.0]); size = 1)\n    V_pre = TestFESpace(U_pre)\n\n    velocity = FEFunction(U_vel)\n    pressure = FEFunction(U_pre)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Define measures for cell","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    dΩ = Measure(CellDomain(mesh), degquad)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Definition of bilinear and linear forms Tentative velocity forms","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    m1(u, v) = ∫(u ⋅ v)dΩ\n    # function l1(v)\n    #     ∫(velocity ⋅ v)dΩ - Δt * ∫(ν * ∇(velocity) ⊡ ∇(v) + (∇(velocity) * velocity) ⋅ v)dΩ\n    # end\n    # Below is an equivalent définition of l1(v) that yields better performance thanks to the use of composition\n    function l1(v)\n        f(u, ∇u, v, ∇v) = u ⋅ v - Δt * (ν * ∇u ⊡ ∇v + (∇u * u) ⋅ v)\n        ∫(f ∘ (velocity, ∇(velocity), v, ∇(v)))dΩ\n    end","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Pressure forms","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    a2(p, q) = ∫(∇(p) ⋅ ∇(q))dΩ\n    # l2(q) = (-1.0 / Δt) * ∫(tr(∇(velocity)) ⋅ q)dΩ\n    # Below is an equivalent définition of l2(v) that yields better performance thanks to the use of composition\n    function l2(q)\n        f(∇u, q) = (-1.0 / Δt) * (tr(∇u) ⋅ q)\n        ∫(f ∘ (∇(velocity), q))dΩ\n    end","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Velocity correction forms","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    # l3(v) = ∫(velocity ⋅ v)dΩ - Δt * ∫(∇(pressure) ⋅ v)dΩ\n    # Below is an equivalent définition of l3(v) that yields better performance thanks to the use of composition\n    function l3(v)\n        f(u, ∇p, v) = u ⋅ v - Δt * ∇p ⋅ v\n        ∫(f ∘ (velocity, ∇(pressure), v))dΩ\n    end","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Assemble and factorize matrices","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    M1 = assemble_bilinear(m1, U_vel, V_vel)\n    M0 = copy(M1)\n    Bcube.apply_dirichlet_to_matrix!(M1, U_vel, V_vel, mesh)\n    f_M1 = factorize(M1)\n\n    A2 = assemble_bilinear(a2, U_pre, V_pre)\n    Bcube.apply_dirichlet_to_matrix!(A2, U_pre, V_pre, mesh)\n    f_A2 = factorize(A2)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Write initial solution","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    vars = Dict(\"Velocity\" => velocity, \"Pressure\" => pressure)\n    filepath = joinpath(outputpath, \"output_projection.pvd\")\n    write_file(filepath, mesh, vars, 0, 0.0; collection_append = false)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Time stepping","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    time = 0.0\n    itime = 0\n\n    while time <= finalTime\n        time += Δt\n        itime += 1\n\n        println(\"Time stepping : time = \", time, \" / \", finalTime)\n\n        # assemble l1\n        L1 = assemble_linear(l1, V_vel)\n        Wd = Bcube.assemble_dirichlet_vector(U_vel, V_vel, mesh, time)\n        Wd = collect(Wd)\n        # Apply lift\n        L1 = L1 - M0 * Wd\n\n        # Apply homogeneous Dirichlet condition\n        Bcube.apply_homogeneous_dirichlet_to_vector!(L1, U_vel, V_vel, mesh)\n\n        # Compute tentative velocity\n        sol = f_M1 \\ L1\n\n        set_dof_values!(velocity, sol .+ Wd)\n\n        # Assemble l2\n        L2 = assemble_linear(l2, V_pre)\n        Bcube.apply_homogeneous_dirichlet_to_vector!(L2, U_pre, V_pre, mesh)\n\n        # Compute pressure\n        sol = f_A2 \\ L2\n\n        set_dof_values!(pressure, sol)\n\n        # Assemble l3\n        L3 = assemble_linear(l3, V_vel)\n        # Apply lift\n        L3 = L3 - M0 * Wd\n\n        # Apply homogeneous Dirichlet condition\n        Bcube.apply_homogeneous_dirichlet_to_vector!(L3, U_vel, V_vel, mesh)\n\n        # Velocity correction step\n        sol = f_M1 \\ L3\n\n        set_dof_values!(velocity, sol .+ Wd)\n\n        # Write outputs\n        if itime % 100 == 0\n            write_file(filepath, mesh, vars, itime, time; collection_append = true)\n        end\n    end\nend","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"The animation below shows the result of simulation with the projection method: (Image: )","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Function that solves the problem using a mixed formalism","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"function run_unsteady_mixed()","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Read mesh","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    mesh = read_mesh(meshpath)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Definition of trial and test function spaces (with associated Dirichlet boundary conditions)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    fsu = FunctionSpace(fspace, degree_u)\n    U_vel = TrialFESpace(\n        fsu,\n        mesh,\n        Dict(\n            \"left\" => inlet_velocity,\n            \"top\" => SA[0.0, 0.0],\n            \"bottom\" => SA[0.0, 0.0],\n            \"cylinder\" => SA[0.0, 0.0],\n        );\n        size = 2,\n    )\n    V_vel = TestFESpace(U_vel)\n\n    fsp = FunctionSpace(fspace, degree_p)\n    U_pre = TrialFESpace(fsp, mesh; size = 1)\n    V_pre = TestFESpace(U_pre)\n\n    U = MultiFESpace(U_vel, U_pre)\n    V = MultiFESpace(V_vel, V_pre)\n\n    velocity = FEFunction(U_vel)\n    pressure = FEFunction(U_pre)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Define measures for cell","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    dΩ = Measure(CellDomain(mesh), degquad)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Definition of bilinear and linear forms","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    m((u, p), (v, q)) = ∫(u ⋅ v)dΩ\n    a((u, p), (v, q)) = ∫(ν * ∇(u) ⊡ ∇(v) - tr(∇(v)) * p + tr(∇(u)) * q)dΩ\n    l((v, q)) = -∫((∇(velocity) * velocity) ⋅ v)dΩ","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Assemble and factorize matrices","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    M = assemble_bilinear(m, U, V)\n    A = assemble_bilinear(a, U, V)\n    L = assemble_linear(l, V)\n    A0 = copy(A)\n\n    Bcube.apply_dirichlet_to_matrix!(A, U, V, mesh)\n    Bcube.apply_dirichlet_to_matrix!(M, U, V, mesh)\n\n    f_Mtime = factorize(M .+ Δt * A)\n\n    ϕ = FEFunction(V)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Initial output","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    vars = Dict(\"Velocity\" => velocity, \"Pressure\" => pressure)\n    filepath = joinpath(outputpath, \"output_mixed.pvd\")\n    write_file(filepath, mesh, vars, 0, 0.0; collection_append = false)","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"Time stepping","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"    time = 0.0\n    itime = 0\n    sol = zero(L)\n\n    while time <= finalTime\n        time += Δt\n        itime += 1\n\n        println(\"Time stepping : time = \", time, \" / \", finalTime)\n\n        L = assemble_linear(l, V)\n\n        Wd = Bcube.assemble_dirichlet_vector(U, V, mesh, time)\n        Wd = collect(Wd)\n\n        # Apply lift\n        L = L - A0 * Wd\n\n        # Apply homogeneous Dirichlet condition\n        Bcube.apply_homogeneous_dirichlet_to_vector!(L, U, V, mesh)\n\n        # Compute solution\n        sol = f_Mtime \\ (Δt * L + M * sol)\n\n        set_dof_values!(ϕ, sol .+ Wd)\n        velocity, pressure = ϕ\n\n        # Write outputs\n        if itime % 100 == 0\n            vars = Dict(\"Velocity\" => velocity, \"Pressure\" => pressure)\n            write_file(filepath, mesh, vars, itime, time; collection_append = true)\n        end\n    end\nend","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"The animation below shows the result of simulation with the \"mixed form\" method: (Image: )","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"println(\" \")\nprintln(\"---------------------------------------------------\")\nprintln(\"--------- solving with projection method ----------\")\n@time begin\n    run_unsteady_projection_method()\nend\nprintln(\"---------------------------------------------------\")\nprintln(\" \")\nprintln(\"---------------------------------------------------\")\nprintln(\"--------- solving with mixed form method ----------\")\n@time begin\n    run_unsteady_mixed()\nend\nprintln(\"---------------------------------------------------\")\nprintln(\" \")","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"","category":"page"},{"location":"example/incompressible_navier_stokes/","page":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","title":"Incompressible Navier-Stokes (FEM) - flow around a cylinder","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example/linear_thermoelasticity/#Thermo-elasticity","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"","category":"section"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"const dir = string(@__DIR__, \"/\") # Bcube dir\nusing Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing LinearAlgebra\nusing StaticArrays","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"Function space (here we shall use Lagrange P1 elements) and quadrature degree.","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"const fspace = :Lagrange\nconst degree = 1 # FunctionSpace degree\nconst degquad = 2 * degree + 1","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"Input and output paths","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"const outputpath = joinpath(dir, \"../../../myout/linear_thermoelasticity/\")\nconst meshpath = joinpath(dir, \"../../../input/mesh/domainThermoElast_tri.msh\")","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"Time stepping scheme params","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"const α = 0.05\nconst γ = 0.5 + α\nconst β = 0.25 * (1.0 + α)^2\n\nconst totalTime = 10.0\nconst Δt = 1.0e-2","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"Material parameters (Young's modulus, Poisson coefficient and deduced Lamé coefficients)","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"const E = 200.0e9\nconst ν = 0.3\nconst λ = E * ν / ((1.0 + ν) * (1.0 - 2.0 * ν))\nconst μ = E / (2.0 * (1.0 + ν))\nconst Kₜ = 1.0e-6\nconst ρ = 2500.0\nconst cₚ = 1000.0\nconst k = 250.0\nconst T₀ = 280.0","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"Strain tensor and stress tensor (Hooke's law)","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"ϵ(u) = 0.5 * (∇(u) + transpose(∇(u)))\nσ(u) = λ * tr(ϵ(u)) * I + 2 * μ * (ϵ(u)) # Elastic stress\nσₜ(T) = (3 * λ + 2 * μ) * Kₜ * (T - T₀) * I # Thermal stress\n\nπ(u, v) = σ(u) ⊡ ϵ(v) # with the chosen contraction convention ϵ should be transposed, but as it is symmetric the expression remains correct\nπₜ(T, v) = σₜ(T) ⊡ ϵ(v)","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"materialize for identity operator","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"Bcube.materialize(A::LinearAlgebra.UniformScaling, B) = A","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"Function that performs a time step using a Newmark α-HHT scheme The scheme updates the acceleration G, the velocity V and the displacement U using the following formulas:","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"begincases\n  M G^n+1 +(1-alpha)A U^n+1 + alpha A U^n = (1-alpha) L^n+1 + alpha L^n = L textrm(because here L is time independent) \n  V^n+1 = V^n + (1-gamma) Delta t G^n + gamma Delta t G^n+1 \n  U^n+1 = U^n + Delta t V^n + (frac12 - beta)*Delta t^2 G^n + beta Delta t^2 G^n+1\nendcases","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"where M is the mass matrix, A is the stiffness matrix and L is the RHS G is then computed by solving the linear system obtained by inserting the expressions for U and V in the equation for G.","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"function Newmark_α_HHT(dt, L, A, Mat, U0, V0, G0)\n    L1 = L - α * A * U0\n    L2 = -(1.0 - α) * (A * U0 + dt * A * V0 + (0.5 - β) * dt * dt * A * G0)\n    RHS = L1 .+ L2\n\n    G = Mat \\ RHS\n    U = U0 + dt * V0 + (0.5 - β) * dt * dt * G0 + β * dt * dt * G\n    V = V0 + (1.0 - γ) * dt * G0 + γ * dt * G\n\n    return U, V, G\nend","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"Function that runs the unsteady case:","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"function run_unsteady()\n    mesh = read_mesh(meshpath)\n\n    fs = FunctionSpace(fspace, degree)\n    U_scal = TrialFESpace(fs, mesh, Dict(\"West1\" => 280.0, \"East1\" => 280.0); size = 1)\n    V_scal = TestFESpace(U_scal)\n    U_vec = TrialFESpace(\n        fs,\n        mesh,\n        Dict(\"West1\" => SA[0.0, 0.0], \"East1\" => SA[0.0, 0.0]);\n        size = 2,\n    )\n    V_vec = TestFESpace(U_vec)\n\n    # Initialize solution\n    U = FEFunction(U_vec, 0.0)\n    U0 = zeros(Bcube.get_ndofs(U_vec))\n    V0 = zeros(Bcube.get_ndofs(U_vec))\n    G0 = zeros(Bcube.get_ndofs(U_vec))\n\n    T = FEFunction(U_scal, T₀)\n\n    # Define measures for cell\n    dΩ = Measure(CellDomain(mesh), degquad)\n\n    # no volume force term\n    f = PhysicalFunction(x -> SA[0.0, 0.0])\n\n    q = PhysicalFunction(\n        x -> x[1] .* (1.0 .- x[1]) .* x[2] .* (0.2 .- x[2]) .* 1500000000.0,\n    )\n\n    # Definition of bilinear and linear forms for the elasticity problem\n    a(u, v) = ∫(π(u, v))dΩ\n    m(u, v) = ∫(ρ * u ⋅ v)dΩ\n    l(v) = ∫(πₜ(T, v))dΩ\n\n    # An alternative way to define this linear form is to use operator composition:\n    # l(v) = ∫( πₜ ∘ (T, v, ∇(v)) )dΩ\n    # where πₜ(T, v, ∇v) = σₜ(T) ⊡ ϵ(v, ∇v) and ϵ(v, ∇v) = 0.5*( ∇v + transpose(∇v) )\n\n    # Definition of bilinear and linear forms for the heat conduction problem\n    aₜ(u, v) = ∫(k * ∇(u) ⋅ ∇(v))dΩ\n    mₜ(u, v) = ∫(ρ * cₚ * u ⋅ v)dΩ\n    lₜ(v) = ∫(q * v)dΩ\n\n    # Assemble matrices and vector\n    M = assemble_bilinear(m, U_vec, V_vec)\n    A = assemble_bilinear(a, U_vec, V_vec)\n    L = assemble_linear(l, V_vec)\n    AT = assemble_bilinear(aₜ, U_scal, V_scal)\n    MT = assemble_bilinear(mₜ, U_scal, V_scal)\n    LT = assemble_linear(lₜ, V_scal)\n\n    # Apply homogeneous dirichlet on A and b\n    Bcube.apply_homogeneous_dirichlet_to_vector!(L, U_vec, V_vec, mesh)\n    Bcube.apply_dirichlet_to_matrix!((A, M), U_vec, V_vec, mesh)\n\n    # Compute a vector of dofs whose values are zeros everywhere\n    # except on dofs lying on a Dirichlet boundary, where they\n    # take the Dirichlet value\n    Td = Bcube.assemble_dirichlet_vector(U_scal, V_scal, mesh)\n    Td = collect(Td)\n\n    # Apply lift\n    LT = LT - AT * Td\n\n    # Apply homogeneous dirichlet condition\n    Bcube.apply_homogeneous_dirichlet_to_vector!(LT, U_scal, V_scal, mesh)\n    Bcube.apply_dirichlet_to_matrix!((AT, MT), U_scal, V_scal, mesh)\n\n    # Write initial solution\n    mkpath(outputpath)\n    dict_vars = Dict(\"Displacement\" => U, \"Temperature\" => T)\n    # Write the obtained FE solution\n    write_file(\n        outputpath * \"result_thermoelasticity.pvd\",\n        mesh,\n        dict_vars,\n        0,\n        0.0;\n        collection_append = false,\n    )\n\n    # Time loop\n    itime = 0\n    t = 0.0\n\n    # Matrix for time stepping\n    Mat = factorize(M + (1.0 - α) * (β * Δt * Δt * A))\n    Miter = factorize(MT + Δt * AT)\n\n    while t <= totalTime\n        t += Δt\n        itime = itime + 1\n        @show t, itime\n\n        # solve time step heat equation\n        rhs = Δt * LT + MT * (get_dof_values(T) .- Td)\n        set_dof_values!(T, Miter \\ rhs .+ Td)\n\n        # solve time step elasticity\n        U1, V1, G1 = Newmark_α_HHT(Δt, L, A, Mat, U0, V0, G0)\n\n        # Update solution\n        U0 .= U1\n        V0 .= V1\n        G0 .= G1\n\n        set_dof_values!(U, U1)\n        L = assemble_linear(l, V_vec)\n        Bcube.apply_homogeneous_dirichlet_to_vector!(L, U_vec, V_vec, mesh)\n\n        # Write solution\n        if itime % 10 == 0\n            dict_vars = Dict(\"Displacement\" => U, \"Temperature\" => T)\n            # Write the obtained FE solution\n            write_file(\n                outputpath * \"result_thermoelasticity.pvd\",\n                mesh,\n                dict_vars,\n                itime,\n                t;\n                collection_append = true,\n            )\n            # In order to use the warp function in paraview (solid is deformed using the displacement field)\n            # the calculator filter has to be used with the following formula to reconstruct a 3D displacement field\n            # with 0 z-component: Displacement_X*iHat+Displacement_Y*jHat+0.0*kHat\n        end\n    end\nend\n\nrun_unsteady()","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"Here is an animation of the obtained result: (Image: )","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"","category":"page"},{"location":"example/linear_thermoelasticity/","page":"Thermo-elasticity","title":"Thermo-elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/heat_equation/#Heat-equation-(FE)","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"","category":"section"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"In this tutorial, the heat equation (first steady and then unsteady) is solved using finite-elements.","category":"page"},{"location":"tutorial/heat_equation/#Theory","page":"Heat equation (FE)","title":"Theory","text":"","category":"section"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"This example shows how to solve the heat equation with eventually variable physical properties in steady and unsteady formulations:","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"  rho C_p partial_t u - nabla  ( lambda u) = f","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"We shall assume that f  rho  C_p  lambda  in L^2(Omega). The weak form of the problem is given by: find $ u \\in \\tilde{H}^1_0(\\Omega)$ (there will be at least one Dirichlet boundary condition) such that:","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"  forall v in  tildeH^1_0(Omega)    underbraceint_Omega partial_t u  v dx_m(partial_t uv) + underbraceint_Omega nabla u  nabla v dx_a(uv) = underbraceint_Omega f v dx_l(v)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"To numerically solve this problem we seek an approximate solution using Lagrange P^1 or P^2 elements. Here we assume that the domain can be split into two domains having different material properties.","category":"page"},{"location":"tutorial/heat_equation/#Steady-case","page":"Heat equation (FE)","title":"Steady case","text":"","category":"section"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"As usual, start by importing the necessary packages.","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"using Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing LinearAlgebra","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"First we define some physical and numerical constants","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"const htc = 100.0 # Heat transfer coefficient (bnd cdt)\nconst Tr = 268.0 # Recovery temperature (bnd cdt)\nconst phi = 100.0\nconst q = 1500.0\nconst λ = 100.0\nconst η = λ\nconst ρCp = 100.0 * 200.0\nconst degree = 2\nconst outputpath = joinpath(@__DIR__, \"..\", \"..\", \"myout\", \"heat_equation/\")","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Read 2D mesh","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"mesh_path = joinpath(@__DIR__, \"..\", \"..\", \"input\", \"mesh\", \"domainSquare_tri.msh\")\nmesh = read_mesh(mesh_path)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Build function space and associated Trial and Test FE spaces. We impose a Dirichlet condition with a temperature of 260K on boundary \"West\"","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"fs = FunctionSpace(:Lagrange, degree)\nU = TrialFESpace(fs, mesh, Dict(\"West\" => 260.0))\nV = TestFESpace(U)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Define measures for cell integration","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"dΩ = Measure(CellDomain(mesh), 2 * degree + 1)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Define bilinear and linear forms","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"a(u, v) = ∫(η * ∇(u) ⋅ ∇(v))dΩ\nl(v) = ∫(q * v)dΩ","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Create an affine FE system and solve it using the AffineFESystem structure. The package LinearSolve is used behind the scenes, so different solver may be used to invert the system (ex: solve(...; alg = IterativeSolversJL_GMRES())) The result is a FEFunction (ϕ). We can interpolate it on mesh centers : the result is named Tcn.","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"sys = AffineFESystem(a, l, U, V)\nϕ = Bcube.solve(sys)\nTcn = var_on_centers(ϕ, mesh)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Compute analytical solution for comparison. Apply the analytical solution on mesh centers","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"T_analytical = x -> 260.0 + (q / λ) * x[1] * (1.0 - 0.5 * x[1])\nTca = map(T_analytical, get_cell_centers(mesh))","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Write both the obtained FE solution and the analytical solution to a vtk file. To write the data on mesh centers, we need to wrap them in a MeshCellData object.","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"using BcubeVTK\nmkpath(outputpath)\ndict_vars = Dict(\"Temperature\" => MeshCellData(Tcn), \"Temperature_a\" => MeshCellData(Tca))\nwrite_file(outputpath * \"result_steady_heat_equation.pvd\", mesh, dict_vars)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Compute and display the error","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"@show norm(Tcn .- Tca, Inf) / norm(Tca, Inf)","category":"page"},{"location":"tutorial/heat_equation/#Unsteady-case","page":"Heat equation (FE)","title":"Unsteady case","text":"","category":"section"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"The code for the unsteady case if of course very similar to the steady case, at least for the beginning. Start by defining two additional parameters:","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"totalTime = 100.0\nΔt = 0.1","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Read a slightly different mesh","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"mesh_path = joinpath(@__DIR__, \"..\", \"..\", \"input\", \"mesh\", \"domainSquare_tri_2.msh\")\nmesh = read_mesh(mesh_path)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"The rest is similar to the steady case","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"fs = FunctionSpace(:Lagrange, degree)\nU = TrialFESpace(fs, mesh, Dict(\"West\" => 260.0))\nV = TestFESpace(U)\ndΩ = Measure(CellDomain(mesh), 2 * degree + 1)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Compute matrices associated to bilinear and linear forms, and assemble","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"a(u, v) = ∫(η * ∇(u) ⋅ ∇(v))dΩ\nm(u, v) = ∫(ρCp * u ⋅ v)dΩ\nl(v) = ∫(q * v)dΩ\n\nA = assemble_bilinear(a, U, V)\nM = assemble_bilinear(m, U, V)\nL = assemble_linear(l, V)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Compute a vector of dofs whose values are zeros everywhere except on dofs lying on a Dirichlet boundary, where they take the Dirichlet value. The returned vector is a \"SparseVector\". Since we will use it in a linear system inversion, we must convert it to a \"regular\" vector.","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Ud = collect(assemble_dirichlet_vector(U, V, mesh))","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Apply lift","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"L = L - A * Ud","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Apply homogeneous dirichlet condition","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"apply_homogeneous_dirichlet_to_vector!(L, U, V, mesh)\napply_dirichlet_to_matrix!((A, M), U, V, mesh)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Form time iteration matrix (note that this is bad for performance since up to now, M and A are sparse matrices)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Miter = factorize(M + Δt * A)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Init the solution with a constant temperature of 260K","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"ϕ = FEFunction(U, 260.0)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Write initial solution to a file","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"mkpath(outputpath)\ndict_vars = Dict(\"Temperature\" => MeshCellData(var_on_centers(ϕ, mesh)))\nwrite_file(outputpath * \"result_unsteady_heat_equation.pvd\", mesh, dict_vars, 0, 0.0)","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"Time loop","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"itime = 0\nt = 0.0\nwhile t <= totalTime\n    global t, itime\n    t += Δt\n    itime = itime + 1\n    @show t, itime\n\n    # Compute rhs\n    rhs = Δt * L + M * (get_dof_values(ϕ) .- Ud)\n\n    # Invert system and apply inverse shift\n    set_dof_values!(ϕ, Miter \\ rhs .+ Ud)\n\n    # Write solution (every 10 iterations)\n    if itime % 10 == 0\n        dict_vars = Dict(\"Temperature\" => MeshCellData(var_on_centers(ϕ, mesh)))\n        write_file(\n            outputpath * \"result_unsteady_heat_equation.pvd\",\n            mesh,\n            dict_vars,\n            itime,\n            t;\n            collection_append = true,\n        )\n    end\nend\n\n","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"","category":"page"},{"location":"tutorial/heat_equation/","page":"Heat equation (FE)","title":"Heat equation (FE)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example/constrained_poisson/#Constrained-Poisson-equation-(FE)","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"","category":"section"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"In this example, a Poisson equation with Neumann boundary conditions is solved using a boundary integral constraint.","category":"page"},{"location":"example/constrained_poisson/#Theory","page":"Constrained Poisson equation (FE)","title":"Theory","text":"","category":"section"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Consider the following Poisson equation on the unit disk (noted Omega in this example, its boundary is noted Gamma):","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"begincases\n- Delta u = f   forall x in Omega \nfracpartial upartial n = 0   forall x in Gamma\nendcases","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Poisson's equation can be written in the form of a minimisation problem:","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"   min_u J(u) = frac12 int_Omega nabla u cdot nabla u  dV - int_Omega f u  dV","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"There is no unique solution to this problem (adding a constant to any solution will also be a solution). Uniqueness can be recovered by adding a constraint to the problem. In this example the following constraint is added:","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"   int_Gamma u  d gamma = 2 pi","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"To solve this constrained minimisation problem, the following lagragian is introduced:","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"   mathcalL(u lambda_u) = frac12 int_Omega nabla u cdot nabla u  dV - int_Omega f u  dV + lambda_u ( int_Gamma u  d gamma - 2 pi)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"where lambda_u is a Lagrange multiplier. The first order optimality conditions translate to the problem: find (u lambda_u) such that for all (v lambda_v):","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"   int_Omega nabla u cdot nabla v  dV + lambda_u int_Gamma v  d gamma = int_Omega f v  dV","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"   lambda_v int_Gamma u  dgamma = 2 pi lambda_v","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"This problem can be assembled by introducing a MultiplierFESpace and combining it with the usual FESpace using a MultiFESpace. In this example, the manufactured solution u(xy)=cos(4pi(x^2 + y^2)) is used to test the method.","category":"page"},{"location":"example/constrained_poisson/#Commented-code","page":"Constrained Poisson equation (FE)","title":"Commented code","text":"","category":"section"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"import necessary packages","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"using Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing LinearAlgebra\nusing SparseArrays\n\nconst outputpath = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"myout\", \"constrained_poisson\")\nmkpath(outputpath)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Read 2D mesh","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"mesh_path = joinpath(outputpath, \"mesh.msh\")\nBcubeGmsh.gen_disk_mesh(mesh_path; lc = 3.2e-2)\nmesh = read_mesh(mesh_path)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Choose degree and define function space, trial space and test space","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"const degree = 2\nfs = FunctionSpace(:Lagrange, degree)\nU = TrialFESpace(fs, mesh)\nV = TestFESpace(U)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Define the multiplier trial space and corresponding test space The second argument of MultiplierFESpace specifies the number of scalar Lagrange multipliers that are to be used for the problem.","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Λᵤ = MultiplierFESpace(mesh, 1)\nΛᵥ = TestFESpace(Λᵤ)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"The usual trial FE space and multiplier space are combined into a MultiFESpace","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"P = MultiFESpace(U, Λᵤ)\nQ = MultiFESpace(V, Λᵥ)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Define volume and boundary measures","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"dΩ = Measure(CellDomain(mesh), 2 * degree + 1)\nΓ = BoundaryFaceDomain(mesh, (\"BORDER\",))\ndΓ = Measure(Γ, 2 * degree + 1)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Define solution FE Function","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"ϕ = FEFunction(U)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Define source term function (deduced from manufactured solution)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"f = PhysicalFunction(\n    x ->\n        64.0 * π^2 * (x[1]^2 + x[2]^2) * cos(4.0 * π * (x[1]^2 + x[2]^2)) +\n        16.0 * π * sin(4.0 * π * (x[1]^2 + x[2]^2)),\n)\n\nvolume = sum(Bcube.compute(∫(PhysicalFunction(x -> 1.0))dΩ))","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Define bilinear and linear forms","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"function a((u, λᵤ), (v, λᵥ))\n    ∫(∇(u) ⋅ ∇(v))dΩ + ∫(side⁻(λᵤ) * side⁻(v))dΓ + ∫(side⁻(λᵥ) * side⁻(u))dΓ\nend","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"For the time being only functionals in the form of integrals can be assembled. A temporary workaround is to put the multiplier in the integral and divide by the volume (the multiplier does not vary in space).","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"l((v, λᵥ)) = ∫(f * v + 2.0 * π * λᵥ / volume)dΩ","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Assemble to get matrices and vectors","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"A = assemble_bilinear(a, P, Q)\nL = assemble_linear(l, Q)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Solve problem","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"sol = A \\ L\n\nϕ = FEFunction(Q)","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"Write solution and compare to analytical solution","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"set_dof_values!(ϕ, sol)\nu, λ = ϕ\n\nprintln(\"Value of Lagrange multiplier : \", λ.dofValues[1])\n\nu_ref = PhysicalFunction(x -> cos(4.0 * π * (x[1]^2 + x[2]^2)))\nerror = u_ref - u\n\nvars = Dict(\"Numerical solution\" => u, \"Analytical solution\" => u_ref, \"error\" => error)\nfilename = joinpath(outputpath, \"output.pvd\")\nwrite_file(filename, mesh, U, vars)\n\nl2(u) = sqrt(sum(Bcube.compute(∫(u ⋅ u)dΩ)))\nel2 = l2(error) / l2(u_ref)\ntol = 1.e-3\nprintln(\"L2 relative error : \", el2)\n\n","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"","category":"page"},{"location":"example/constrained_poisson/","page":"Constrained Poisson equation (FE)","title":"Constrained Poisson equation (FE)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example/covo/#Euler-equations-covo","page":"Euler equations - covo","title":"Euler equations - covo","text":"","category":"section"},{"location":"example/covo/","page":"Euler equations - covo","title":"Euler equations - covo","text":"module Covo #hide\nprintln(\"Running covo example...\") #hide\n\nconst dir = string(@__DIR__, \"/\")\nusing Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing LinearAlgebra\nusing StaticArrays\nusing Profile\nusing StaticArrays\nusing InteractiveUtils\nusing BenchmarkTools\nusing UnPack\n\nfunction compute_residual(_u, V, params, cache)\n    u = get_fe_functions(_u)\n\n    # alias on measures\n    @unpack dΩ, dΓ, dΓ_perio_x, dΓ_perio_y = params\n\n    # face normals for each face domain (lazy, no computation at this step)\n    nΓ = get_face_normals(dΓ)\n    nΓ_perio_x = get_face_normals(dΓ_perio_x)\n    nΓ_perio_y = get_face_normals(dΓ_perio_y)\n\n    # flux residuals from faces for all variables\n    function l(v)\n        ∫(flux_Ω(u, v))dΩ +\n        -∫(flux_Γ(u, v, nΓ))dΓ +\n        -∫(flux_Γ(u, v, nΓ_perio_x))dΓ_perio_x +\n        -∫(flux_Γ(u, v, nΓ_perio_y))dΓ_perio_y\n    end\n\n    rhs = assemble_linear(l, V)\n\n    return cache.mass \\ rhs\nend\n\n\"\"\"\n    flux_Ω(u, v)\n\nCompute volume residual using the lazy-operators approach\n\"\"\"\nflux_Ω(u, v) = _flux_Ω ∘ cellvar(u, v)\ncellvar(u, v) = (u, map(∇, v))\nfunction _flux_Ω(u, ∇v)\n    ρ, ρu, ρE, ϕ = u\n    ∇λ_ρ, ∇λ_ρu, ∇λ_ρE, ∇λ_ϕ = ∇v\n\n    vel = ρu ./ ρ\n    ρuu = ρu * transpose(vel)\n    p   = pressure(ρ, ρu, ρE, γ)\n\n    flux_ρ  = ρu\n    flux_ρu = ρuu + p * I\n    flux_ρE = (ρE + p) .* vel\n    flux_ϕ  = ϕ .* vel\n\n    return ∇λ_ρ ⋅ flux_ρ + ∇λ_ρu ⊡ flux_ρu + ∇λ_ρE ⋅ flux_ρE + ∇λ_ϕ ⋅ flux_ϕ\nend\n\n\"\"\"\n    flux_Γ(u,v,n)\n\nFlux at the interface is defined by a composition of two functions:\n* facevar(u,v,n) defines the input states which are needed for\n  the riemann flux using operator notations\n* flux_roe(w) defines the Riemann flux (as usual)\n\"\"\"\nflux_Γ(u, v, n) = flux_roe ∘ (side⁻(u), side⁺(u), jump(v), side⁻(n))\n\n\"\"\"\n    flux_roe(w)\n\"\"\"\nfunction flux_roe(ui, uj, δv, nij)\n    # destructuring inputs given by `facevar` function\n\n    nx, ny = nij\n    ρ1, ρu1, ρE1, ϕ1 = ui\n    ρ2, ρu2, ρE2, ϕ2 = uj\n    δλ_ρ1, δλ_ρu1, δλ_ρE1, δλ_ϕ1 = δv\n    ρux1, ρuy1 = ρu1\n    ρux2, ρuy2 = ρu2\n\n    # Closure\n    u1 = ρux1 / ρ1\n    v1 = ρuy1 / ρ1\n    u2 = ρux2 / ρ2\n    v2 = ρuy2 / ρ2\n    p1 = pressure(ρ1, ρu1, ρE1, γ)\n    p2 = pressure(ρ2, ρu2, ρE2, γ)\n\n    H2 = (γ / (γ - 1)) * p2 / ρ2 + (u2 * u2 + v2 * v2) / 2.0\n    H1 = (γ / (γ - 1)) * p1 / ρ1 + (u1 * u1 + v1 * v1) / 2.0\n\n    R = √(ρ1 / ρ2)\n    invR1 = 1.0 / (R + 1)\n    uAv = (R * u1 + u2) * invR1\n    vAv = (R * v1 + v2) * invR1\n    Hav = (R * H1 + H2) * invR1\n    cAv = √(abs((γ - 1) * (Hav - (uAv * uAv + vAv * vAv) / 2.0)))\n    ecAv = (uAv * uAv + vAv * vAv) / 2.0\n\n    λ1 = nx * uAv + ny * vAv\n    λ3 = λ1 + cAv\n    λ4 = λ1 - cAv\n\n    d1 = ρ1 - ρ2\n    d2 = ρ1 * u1 - ρ2 * u2\n    d3 = ρ1 * v1 - ρ2 * v2\n    d4 = ρE1 - ρE2\n\n    # computation of the centered part of the flux\n    flu11 = nx * ρ2 * u2 + ny * ρ2 * v2\n    flu21 = nx * p2 + flu11 * u2\n    flu31 = ny * p2 + flu11 * v2\n    flu41 = H2 * flu11\n\n    # Temp variables\n    rc1 = (γ - 1) / cAv\n    rc2 = (γ - 1) / cAv / cAv\n    uq41 = ecAv / cAv + cAv / (γ - 1)\n    uq42 = nx * uAv + ny * vAv\n\n    fdc1 = max(λ1, 0.0) * (d1 + rc2 * (-ecAv * d1 + uAv * d2 + vAv * d3 - d4))\n    fdc2 = max(λ1, 0.0) * ((nx * vAv - ny * uAv) * d1 + ny * d2 - nx * d3)\n    fdc3 =\n        max(λ3, 0.0) * (\n            (-uq42 * d1 + nx * d2 + ny * d3) / 2.0 +\n            rc1 * (ecAv * d1 - uAv * d2 - vAv * d3 + d4) / 2.0\n        )\n    fdc4 =\n        max(λ4, 0.0) * (\n            (uq42 * d1 - nx * d2 - ny * d3) / 2.0 +\n            rc1 * (ecAv * d1 - uAv * d2 - vAv * d3 + d4) / 2.0\n        )\n\n    duv1 = fdc1 + (fdc3 + fdc4) / cAv\n    duv2 = uAv * fdc1 + ny * fdc2 + (uAv / cAv + nx) * fdc3 + (uAv / cAv - nx) * fdc4\n    duv3 = vAv * fdc1 - nx * fdc2 + (vAv / cAv + ny) * fdc3 + (vAv / cAv - ny) * fdc4\n    duv4 =\n        ecAv * fdc1 +\n        (ny * uAv - nx * vAv) * fdc2 +\n        (uq41 + uq42) * fdc3 +\n        (uq41 - uq42) * fdc4\n\n    v₁₂ = 0.5 * ((u1 + u2) * nx + (v1 + v2) * ny)\n    fluxϕ = max(0.0, v₁₂) * ϕ1 + min(0.0, v₁₂) * ϕ2\n\n    return (\n        δλ_ρ1 * (flu11 + duv1) +\n        δλ_ρu1 ⋅ (SA[flu21 + duv2, flu31 + duv3]) +\n        δλ_ρE1 * (flu41 + duv4) +\n        δλ_ϕ1 * (fluxϕ)\n    )\nend\n\n\"\"\"\nTime integration of `f(q, t)` over a timestep `Δt`.\n\"\"\"\nforward_euler(q, f::Function, t, Δt) = get_dof_values(q) .+ Δt .* f(q, t)\n\n\"\"\"\n    rk3_ssp(q, f::Function, t, Δt)\n\n`f(q, t)` is the function to integrate.\n\"\"\"\nfunction rk3_ssp(q, f::Function, t, Δt)\n    stepper(q, t) = forward_euler(q, f, t, Δt)\n    _q0 = get_dof_values(q)\n\n    _q1 = stepper(q, Δt)\n\n    set_dof_values!(q, _q1)\n    _q2 = (3 / 4) .* _q0 .+ (1 / 4) .* stepper(q, t + Δt)\n\n    set_dof_values!(q, _q2)\n    _q1 .= (1 / 3) * _q0 .+ (2 / 3) .* stepper(q, t + Δt / 2)\n\n    return _q1\nend\n\n\"\"\"\n    pressure(ρ, ρu, ρE, γ)\n\nComputes pressure from perfect gaz law\n\"\"\"\nfunction pressure(ρ::Number, ρu::AbstractVector, ρE::Number, γ)\n    vel = ρu ./ ρ\n    ρuu = ρu * transpose(vel)\n    p = (γ - 1) * (ρE - tr(ρuu) / 2)\n    return p\nend\n\n\"\"\"\n  Init field with a vortex (for the COVO test case)\n\"\"\"\nfunction covo!(q, dΩ)\n\n    # Intermediate vars\n    Cₚ = γ * r / (γ - 1)\n\n    r²(x) = ((x[1] .- xvc) .^ 2 + (x[2] .- yvc) .^ 2) ./ Rc^2\n    # Temperature\n    T(x) = T₀ .- β^2 * U₀^2 / (2 * Cₚ) .* exp.(-r²(x))\n    # Velocity\n    ux(x) = U₀ .- β * U₀ / Rc .* (x[2] .- yvc) .* exp.(-r²(x) ./ 2)\n    uy(x) = V₀ .+ β * U₀ / Rc .* (x[1] .- xvc) .* exp.(-r²(x) ./ 2)\n    # Density\n    ρ(x) = ρ₀ .* (T(x) ./ T₀) .^ (1.0 / (γ - 1))\n    # momentum\n    ρu(x) = SA[ρ(x) * ux(x), ρ(x) * uy(x)]\n    # Energy\n    ρE(x) = ρ(x) * ((Cₚ / γ) .* T(x) + (ux(x) .^ 2 + uy(x) .^ 2) ./ 2)\n    # Passive scalar\n    ϕ(x) = Rc^2 * r²(x) < 0.01 ? exp(-r²(x) ./ 2) : 0.0\n\n    f = map(PhysicalFunction, (ρ, ρu, ρE, ϕ))\n    projection_l2!(q, f, dΩ)\n    return nothing\nend\n\n\"\"\"\n    Tiny struct to ease the VTK output\n\"\"\"\nmutable struct VtkHandler\n    basename::Any\n    ite::Any\n    VtkHandler(basename) = new(basename, 0)\nend\n\n\"\"\"\n    Write solution to vtk\n    Wrapper for `write_vtk`\n\"\"\"\nfunction append_vtk(vtk, mesh, vars, t, params)\n    ρ, ρu, ρE, ϕ = vars\n\n    mesh_degree = 1\n    vtk_degree = maximum(x -> get_degree(Bcube.get_function_space(get_fespace(x))), vars)\n    vtk_degree = max(1, mesh_degree, vtk_degree)\n\n    # p = pressure(ρ, ρu, ρE, γ)\n    p = pressure ∘ (ρ, ρu, ρE, γ)\n    dict_vars_dg = Dict(\"rho\" => ρ, \"rhou\" => ρu, \"rhoE\" => ρE, \"phi\" => ϕ, \"p\" => p)\n    write_file(\n        vtk.basename * \"_DG.pvd\",\n        mesh,\n        dict_vars_dg,\n        vtk.ite,\n        t;\n        discontinuous = true,\n        mesh_degree = vtk_degree,\n        collection_append = vtk.ite > 0,\n    )\n\n    # Update counter\n    vtk.ite += 1\nend\n\n# Settings\nif get(ENV, \"BenchmarkMode\", \"false\") == \"false\" #hide\n    const cellfactor = 1\n    const nx = 32 * cellfactor + 1\n    const ny = 32 * cellfactor + 1\n    const fspace = :Lagrange\n    const timeScheme = :ForwardEuler\nelse #hide\n    const nx = 128 + 1 #hide\n    const ny = 128 + 1 #hide\n    const fspace = :Lagrange\n    const timeScheme = :ForwardEuler\nend #hide\nconst nperiod = 1 # number of turn\nconst CFL = 0.1\nconst degree = 1 # FunctionSpace degree\nconst degquad = 2 * degree + 1\nconst γ = 1.4\nconst β = 0.2 # vortex intensity\nconst r = 287.15 # Perfect gaz constant\nconst T₀ = 300 # mean-flow temperature\nconst P₀ = 1e5 # mean-flow pressure\nconst M₀ = 0.5 # mean-flow mach number\nconst ρ₀ = 1.0 # mean-flow density\nconst xvc = 0.0 # x-center of vortex\nconst yvc = 0.0 # y-center of vortex\nconst Rc = 0.005 # Charasteristic vortex radius\nconst c₀ = √(γ * r * T₀) # Sound velocity\nconst U₀ = M₀ * c₀ # mean-flow velocity\nconst V₀ = 0.0 # mean-flow velocity\nconst ϕ₀ = 1.0\nconst l = 0.05 # half-width of the domain\nconst Δt = CFL * 2 * l / (nx - 1) / ((1 + β) * U₀ + c₀) / (2 * degree + 1)\n#const Δt = 5.e-7\nconst nout = 100 # Number of time steps to save\nconst outputpath = \"../../../myout/covo/\"\nconst output = joinpath(@__DIR__, outputpath, \"covo_deg$degree\")\nconst nite = Int(floor(nperiod * 2 * l / (U₀ * Δt))) + 1\n\nfunction run_covo()\n    println(\"Starting run_covo...\")\n\n    # Build mesh\n    meshParam = (nx = nx, ny = ny, lx = 2l, ly = 2l, xc = 0.0, yc = 0.0)\n    tmp_path = \"tmp.msh\"\n    if get(ENV, \"BenchmarkMode\", \"false\") == \"false\" #hide\n        BcubeGmsh.gen_rectangle_mesh(tmp_path, :quad; meshParam...)\n    else #hide\n        if get(ENV, \"MeshConfig\", \"quad\") == \"triquad\" #hide\n            BcubeGmsh.gen_rectangle_mesh_with_tri_and_quad(tmp_path; meshParam...) #hide\n        else #hide\n            BcubeGmsh.gen_rectangle_mesh(tmp_path, :quad; meshParam...) #hide\n        end #hide\n    end #hide\n    mesh = read_mesh(tmp_path)\n    rm(tmp_path)\n\n    # Define variables and test functions\n    fs = FunctionSpace(fspace, degree)\n    U_sca = TrialFESpace(fs, mesh, :discontinuous; size = 1) # DG, scalar\n    U_vec = TrialFESpace(fs, mesh, :discontinuous; size = 2) # DG, vectoriel\n    V_sca = TestFESpace(U_sca)\n    V_vec = TestFESpace(U_vec)\n    U = MultiFESpace(U_sca, U_vec, U_sca, U_sca)\n    V = MultiFESpace(V_sca, V_vec, V_sca, V_sca)\n    u = FEFunction(U)\n\n    @show Bcube.get_ndofs(U)\n\n    # Define measures for cell and interior face integrations\n    dΩ = Measure(CellDomain(mesh), degquad)\n    dΓ = Measure(InteriorFaceDomain(mesh), degquad)\n\n    # Declare periodic boundary conditions and\n    # create associated domains and measures\n    periodicBCType_x = PeriodicBCType(Translation(SA[-2l, 0.0]), (\"East\",), (\"West\",))\n    periodicBCType_y = PeriodicBCType(Translation(SA[0.0, 2l]), (\"South\",), (\"North\",))\n    Γ_perio_x = BoundaryFaceDomain(mesh, periodicBCType_x)\n    Γ_perio_y = BoundaryFaceDomain(mesh, periodicBCType_y)\n    dΓ_perio_x = Measure(Γ_perio_x, degquad)\n    dΓ_perio_y = Measure(Γ_perio_y, degquad)\n\n    params = (dΩ = dΩ, dΓ = dΓ, dΓ_perio_x = dΓ_perio_x, dΓ_perio_y = dΓ_perio_y)\n\n    # Init vtk\n    mkpath(joinpath(@__DIR__, outputpath))\n    vtk = VtkHandler(output)\n\n    # Init solution\n    t = 0.0\n\n    covo!(u, dΩ)\n\n    # cache mass matrices\n    cache = (mass = factorize(Bcube.build_mass_matrix(U, V, dΩ)),)\n\n    if get(ENV, \"BenchmarkMode\", \"false\") == \"true\" #hide\n        return u, U, V, params, cache\n    end\n\n    # Write initial solution\n    append_vtk(vtk, mesh, u, t, params)\n\n    # Time loop\n    for i in 1:nite\n        println(\"\")\n        println(\"\")\n        println(\"Iteration \", i, \" / \", nite)\n\n        ## Step forward in time\n        rhs(u, t) = compute_residual(u, V, params, cache)\n        if timeScheme == :ForwardEuler\n            unew = forward_euler(u, rhs, time, Δt)\n        elseif timeScheme == :RK3\n            unew = rk3_ssp(u, rhs, time, Δt)\n        else\n            error(\"Unknown time scheme: $timeScheme\")\n        end\n\n        set_dof_values!(u, unew)\n\n        t += Δt\n\n        # Write solution to file\n        if (i % Int(max(floor(nite / nout), 1)) == 0)\n            println(\"--> VTK export\")\n            append_vtk(vtk, mesh, u, t, params)\n        end\n    end\n\n    # Summary and benchmark                                 # ndofs total = 20480\n    _rhs(u, t) = compute_residual(u, V, params, cache)\n    @btime forward_euler($u, $_rhs, $time, $Δt)  # 5.639 ms (1574 allocations: 2.08 MiB)\n    # stepper = w -> explicit_step(w, params, cache, Δt)\n    # RK3_SSP(stepper, (u, v), cache)\n    # @btime RK3_SSP($stepper, ($u, $v), $cache)\n    println(\"ndofs total = \", Bcube.get_ndofs(U))\n    Profile.init(; n = 10^7) # returns the current settings\n    Profile.clear()\n    Profile.clear_malloc_data()\n    @profile begin\n        for i in 1:100\n            forward_euler(u, _rhs, time, Δt)\n        end\n    end\n    @show Δt, U₀, U₀ * t\n    @show boundary_names(mesh)\n    return nothing\nend\n\nif get(ENV, \"BenchmarkMode\", \"false\") == \"false\"\n    mkpath(outputpath)\n    run_covo()\nend\n\nend #hide","category":"page"},{"location":"tutorial/linear_transport/#Linear-transport-(DG)","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"","category":"section"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"In this tutorial, we show how to solve a linear transport equation using a discontinuous-Galerkin framework with Bcube.","category":"page"},{"location":"tutorial/linear_transport/#Theory","page":"Linear transport (DG)","title":"Theory","text":"","category":"section"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"In this example, we solve the following linear transport equation using discontinuous elements:","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"fracpartial phipartial t + nabla cdot (c phi) = 0","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"where c is a constant velocity. Using an explicit time scheme, one obtains:","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"phi^n+1 = phi^n - Delta t nabla cdot (c phi^n)","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"The corresponding weak form of this equation is:","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"int_Omega phi^n+1 v mathrmdOmega = int_Omega phi^n v mathrmdOmega + Delta t left\nint_Omega c phi^n cdot nabla v mathrmdOmega - oint_Gamma left( c phi cdot n right) v mathrmdGamma\nright","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"where Gamma = delta Omega. Adopting the discontinuous Galerkin framework, this equation is written in every mesh cell Omega_i. The cell boundary term involves discontinuous quantities and is replaced by a \"numerical flux\", leading to the expression:","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"int_Omega_i phi^n+1 v mathrmdOmega_i = int_Omega_i phi^n v mathrmdOmega_i + Delta t left\nint_Omega_i c phi^n cdot nabla v mathrmdOmega_i - oint_Gamma_i F^*(phi) v mathrmd Gamma_i\nright","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"For this example, an upwind flux will be used for F^*. Using a matrix formulation, the above equation can be written as:","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"phi^n+1 = phi^n + M^-1(f_Omega - f_Gamma)","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"where M^-1 is the inverse of the mass matrix, f_Omega the volumic flux term and f_Gamma the surfacic flux term.","category":"page"},{"location":"tutorial/linear_transport/#Commented-code","page":"Linear transport (DG)","title":"Commented code","text":"","category":"section"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"Start by importing the necessary packages: Load the necessary packages","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"using Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing LinearAlgebra","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"Before all, to ease to ease the solution VTK output we will write a structure to store the vtk filename and the number of iteration; and a function that exports the solution on demand. Note the use of var_on_nodes_discontinuous to export the solution on the mesh nodes, respecting the discontinuous feature of the solution.","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"mutable struct VtkHandler\n    basename::Any\n    ite::Any\n    mesh::Any\n    VtkHandler(basename, mesh) = new(basename, 0, mesh)\nend\n\nfunction append_vtk(vtk, u::Bcube.AbstractFEFunction, t)\n    # Write\n    write_file(\n        vtk.basename,\n        vtk.mesh,\n        Dict(\"u\" => u),\n        vtk.ite,\n        t;\n        discontinuous = true,\n        collection_append = vtk.ite > 0,\n    )\n\n    # Update counter\n    vtk.ite += 1\nend","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"First, we define some physical and numerical constant parameters","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"const degree = 0 # Function-space degree (Taylor(0) = first order Finite Volume)\nconst c = [1.0, 0.0] # Convection velocity (must be a vector)\nconst nite = 100 # Number of time iteration(s)\nconst CFL = 1 # 0.1 for degree 1\nconst nx = 41 # Number of nodes in the x-direction\nconst ny = 41 # Number of nodes in the y-direction\nconst lx = 2.0 # Domain width\nconst ly = 2.0 # Domain height\nconst Δt = CFL * min(lx / nx, ly / ny) / norm(c) # Time step","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"Then generate the mesh of a rectangle using Gmsh and read it","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"tmp_path = joinpath(@__DIR__, \"..\", \"..\", \"myout\", \"tmp.msh\")\nBcubeGmsh.gen_rectangle_mesh(\n    tmp_path,\n    :quad;\n    nx = nx,\n    ny = ny,\n    lx = lx,\n    ly = ly,\n    xc = 0.0,\n    yc = 0.0,\n)\nmesh = read_mesh(tmp_path)\nrm(tmp_path)","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"We can now init our VtkHandler","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"out_dir = joinpath(@__DIR__, \"..\", \"..\", \"myout\", \"linear_transport\")\nvtk = VtkHandler(joinpath(out_dir, \"linear_transport.pvd\"), mesh)","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"As seen in the previous tutorial, the definition of trial and test spaces needs a mesh and a function space. Here, we select Taylor space, and build discontinuous FE spaces with it. Then an FEFunction, that will represent our solution, is created.","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"fs = FunctionSpace(:Taylor, degree)\nU = TrialFESpace(fs, mesh, :discontinuous)\nV = TestFESpace(U)\nu = FEFunction(U)","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"Define measures for cell and interior face integrations","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"Γ = InteriorFaceDomain(mesh)\nΓ_in = BoundaryFaceDomain(mesh, \"West\")\nΓ_out = BoundaryFaceDomain(mesh, (\"North\", \"East\", \"South\"))\n\ndΩ = Measure(CellDomain(mesh), 2 * degree + 1)\ndΓ = Measure(Γ, 2 * degree + 1)\ndΓ_in = Measure(Γ_in, 2 * degree + 1)\ndΓ_out = Measure(Γ_out, 2 * degree + 1)","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"We will also need the face normals associated to the different face domains. Note that this operation is lazy, nΓ is just an abstract representation on face normals of Γ.","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"nΓ = get_face_normals(Γ)\nnΓ_in = get_face_normals(Γ_in)\nnΓ_out = get_face_normals(Γ_out)","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"Let's move on to the bilinear and linear forms. First, the two easiest ones:","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"m(u, v) = ∫(u ⋅ v)dΩ # Mass matrix\nl_Ω(v) = ∫((c * u) ⋅ ∇(v))dΩ # Volumic convective term","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"For the flux term, we first need to define a numerical flux. It is convenient to define it separately in a dedicated function. Here is the definition of simple upwind flux.","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"function upwind(ui, uj, nij)\n    cij = c ⋅ nij\n    if cij > zero(cij)\n        flux = cij * ui\n    else\n        flux = cij * uj\n    end\n    flux\nend","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"We then define the \"flux\" as the composition of the upwind function and the needed entries: namely the solution on the negative side of the face, the solution on the positive face, and the face normal. The orientation negative/positive is arbitrary, the only convention is that the face normals are oriented from the negative side to the positive side.","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"flux = upwind ∘ (side⁻(u), side⁺(u), side⁻(nΓ))\nl_Γ(v) = ∫(flux * jump(v))dΓ","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"Finally, we define what to perform on the \"two\" boundaries : inlet / oulet. On the inlet, we directly impose the flux with a user defined function that depends on the time (the input is an oscillating wave). On the outlet, we keep our upwind flux but we impose the ghost cell value.","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"bc_in = t -> PhysicalFunction(x -> c .* cos(3 * x[2]) * sin(4 * t)) # flux\nl_Γ_in(v, t) = ∫(side⁻(bc_in(t)) ⋅ side⁻(nΓ_in) * side⁻(v))dΓ_in\nflux_out = upwind ∘ (side⁻(u), 0.0, side⁻(nΓ_out))\nl_Γ_out(v) = ∫(flux_out * side⁻(v))dΓ_out","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"Assemble the (constant) mass matrix. The returned matrix is a sparse matrix. To simplify the tutorial, we will directly compute the inverse mass matrix. But note that way more performant strategies should be employed to solve such a problem (since we don't need the inverse, only the matrix-vector product).","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"M = assemble_bilinear(m, U, V)\ninvM = inv(Matrix(M)) #WARNING : really expensive !!!","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"Let's also create three vectors to avoid allocating them at each time step","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"nd = get_ndofs(V)\nb_vol = zeros(nd)\nb_fac = similar(b_vol)\nrhs = similar(b_vol)","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"The time loop is trivial : at each time step we compute the linear forms using the assemble_ methods, we complete the rhs, perform an explicit step and write the solution.","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"t = 0.0\nfor i in 1:nite\n    global t\n\n    # Reset pre-allocated vectors\n    b_vol .= 0.0\n    b_fac .= 0.0\n\n    # Compute linear forms\n    assemble_linear!(b_vol, l_Ω, V)\n    assemble_linear!(b_fac, l_Γ, V)\n    assemble_linear!(b_fac, v -> l_Γ_in(v, t), V)\n    assemble_linear!(b_fac, l_Γ_out, V)\n\n    # Assemble rhs\n    rhs .= Δt .* invM * (b_vol - b_fac)\n\n    # Update solution\n    u.dofValues .+= rhs\n\n    # Update time\n    t += Δt\n\n    # Write to file\n    append_vtk(vtk, u, t)\nend","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"And here is an animation of the result: (Image: )","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"","category":"page"},{"location":"tutorial/linear_transport/","page":"Linear transport (DG)","title":"Linear transport (DG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example/shallow_water/#Shallow-water","page":"Shallow water","title":"Shallow water","text":"","category":"section"},{"location":"example/shallow_water/","page":"Shallow water","title":"Shallow water","text":"module ShallowWater #hide\nprintln(\"Running shallow_water example...\") #hide\n# # Shallow water equations\n#\n# WARNING : the below explanations are not up to date, the text has been copied from the old-api example.\n#\n# Following \"A conservative Saint-Venant type model to describe the dynamics of thien partially wetting films with\n# regularized forces at the contact line\".\n# The gravity is noted ``g = g_n \\vec{e_n} + \\vec{g_t}`` (note that ``g_n`` is a scalar while ``g_t`` is a vector). The goal is to solve:\n# ```math\n# \\begin{cases}\n#   \\partial_t \\rho h + \\nabla \\cdot \\rho h u = 0 \\\\\n#   \\partial_t \\rho h u + \\nabla \\cdot \\mathcal{F}_{\\rho h u} = h \\left( \\rho g_t - \\nabla P_{gaz} \\right) - \\tilde{\\tau}_{wall} + \\tilde{\\tau}_{air}\n# \\end{cases}\n# ```\n#\n# To simplify a little bit, we assume a constant density. The systems becomes:\n# ```math\n# \\begin{cases}\n#   \\partial_t h + \\nabla \\cdot h u = 0 \\\\\n#   \\partial_t h u + \\nabla \\cdot \\mathcal{F}_{hu} = h \\left( g_t - \\nabla P_{gaz} \\right) - \\tau_{wall} + \\tau_{air}\n# \\end{cases}\n# ```\n# where\n# ```math\n# \\tau_{wall} = \\frac{3 \\nu u}{h + b} - \\frac{\\tau_{air}h}{2(h+b)}\n# ```\n# ``b`` being a slip length and\n# ```math\n# \\mathcal{F}_{h u} = h u \\otimes u + g_n \\frac{h^2}{2} \\mathcal{I} + \\frac{1}{\\rho}\\left[h \\partial_h e_d(h) - e_d(h) \\right]\n# - \\frac{\\gamma_{lg}}{\\rho \\sqrt{1 + ||\\nabla h||^2}} + \\frac{1}{\\rho} \\gamma_{lg} h \\kappa\n# ```\n#\n# ## Explicit time integration\n# ```math\n# \\begin{cases}\n#   h^{n+1} = h^n - \\Delta t \\nabla \\cdot h u^n \\\\\n#   h u^{n+1} =  hu^n - \\Delta t \\left[\n#     \\nabla \\cdot \\mathcal{F}_{hu}(h^n,hu^n)\n#     - h^n \\left( g_t - \\nabla P_{gaz} \\right) + \\tau_{wall}(h^n, hu^n) - \\tau_{air}\n#   \\right]\n# \\end{cases}\n# ```\n#\n# ## Implicit time integration\n# ```math\n# \\begin{cases}\n#   h^{n+1} = h^n - \\Delta t \\nabla \\cdot h u^{n+1} \\\\\n#   h u^{n+1} =  hu^n - \\Delta t \\left[\n#     \\nabla \\cdot \\mathcal{F}_{hu}(h^{n+1},hu^{n+1})\n#     - h^{n+1} \\left( g_t - \\nabla P_{gaz} \\right) + \\tau_{wall}(h^{n+1}, hu^{n+1}) - \\tau_{air}\n#   \\right]\n# \\end{cases}\n# ```\n#\n# ## IMEX time integration (not finished / not relevant)\n# The wall friction term, ``\\tau_w`` is singular when ``h \\rightarrow 0``. To overcome this difficulty, an implicit-explicit (IMEX)\n# scheme is used : all terms are integrated explicitely except the wall friction. More precisely, the system is first written:\n# ```math\n# \\begin{cases}\n#   h^{n+1} = h^n - \\Delta t \\nabla \\cdot h u^n \\\\\n#   h u^{n+1} =  hu^n - \\Delta t \\left[\n#     \\nabla \\cdot \\mathcal{F}_{hu}(h^n,hu^n)\n#     - h^n \\left( g_t - \\nabla P_{gaz} \\right) + \\tau_{wall}(h^{n+1}, hu^{n+1}) - \\tau_{air}\n#   \\right]\n# \\end{cases}\n# ```\n# At each time step, the mass equation can be solved explicitely independantly from the momentum equation. Besides, the wall\n# friction can be expressed as:\n# ```math\n# \\tau_{wall} = \\frac{3 \\nu hu^{n+1}}{{h^{n+1}}^2} - \\frac{\\tau_{air}}{2}\n# ```\n# where the slipping length, ``b``, is neglected (which is fine when working with an implicit formulation). The momentum\n# equation can then be rearranged to obtain:\n# ```math\n#   h u^{n+1}\\left( 1 + \\frac{3  \\nu \\Delta t }{{h^{n+1}}^2} \\right) =  hu^n - \\Delta t \\left[\n#     \\nabla \\cdot \\mathcal{F}_{hu}(h^n,hu^n)\n#     - h^n \\left( g_t - \\nabla P_{gaz} \\right) - \\frac{3}{2}\\tau_{air}\n#   \\right]\n# ```\n# Moving the multiplying factor to the right-hand-side, we finally obtain:\n# ```math\n#   h u^{n+1} = \\frac{{h^{n+1}}^2}{{h^{n+1}}^2 + 3 \\nu \\Delta t} \\left[\n#     hu^n - \\Delta t \\left[\n#       \\nabla \\cdot \\mathcal{F}_{hu}(h^n,hu^n)\n#       - h^n \\left( g_t - \\nabla P_{gaz} \\right) - \\frac{3}{2}\\tau_{air}\n#     \\right]\n#  \\right]\n# ```\n#\n#\n# ## Weak form\n# First we write the different equation with a full explicit scheme to improve clarity.\n#\n# ### Mass conservation equation\n# We multiply the equation by a test function ``\\phi_{h}`` and integrate on a control volume ``\\Omega``. After an integration by parts,\n# we obtain (for an explicit integration time scheme):\n# ```math\n# \\int_{\\Omega} h^{n+1} \\phi_{h} \\mathrm{\\,d}\\Omega = \\int_{\\Omega} h^n \\phi_{h} \\mathrm{\\,d}\\Omega\n# + \\Delta t \\left[ \\int_{\\Omega} h u^n \\cdot \\nabla \\phi_{h} \\mathrm{\\,d}\\Omega\n# - \\oint_{\\Gamma} F_{h}^*(h^n, h u^n) \\phi_{h} \\mathrm{\\,d} \\Gamma \\right]\n# ```\n# where ``F^*_{h}`` is the numerical flux corresponding to ``hu``.\n#\n# ### Momentum conservation equation\n# We first consider the case without contact line forces nor curvature. Multiplying by a test function ``\\phi_{h u}`` and integrating\n# by parts leads to:\n# ```math\n#   \\int_{\\Omega} h u^{n+1} \\phi_{h u} \\mathrm{\\,d}\\Omega = \\int_{\\Omega} h u^n \\phi_{h u} \\mathrm{\\,d}\\Omega\n#   + \\Delta t \\left[\n#     \\int_{\\Omega} \\left[\n#         \\mathcal{F}^n \\cdot \\nabla \\phi_{h u}\n#         + \\left( h^n(g_t - \\nabla P_g) - \\tau_w + \\tau_a \\right) \\phi_{h u}\n#     \\right] \\mathrm{\\,d}\\Omega\n#     - \\oint_{\\Gamma} F_{h u}^*(h^n, h u^n) \\phi_{h u} \\mathrm{\\,d} \\Gamma\n#   \\right]\n# ```\n# where ``F^*_{h u}`` is the numerical flux corresponding to ``h u \\otimes u + g_n h^2 /2 \\mathcal{I}``.\n#\n\nconst dir = string(@__DIR__, \"/\")\nusing Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing LinearAlgebra\nusing StaticArrays\nusing BenchmarkTools\nusing Roots\nusing SparseArrays\nusing SparseDiffTools\nusing Profile\n#using Symbolics\nusing InteractiveUtils\n\nconst eps_h = 1.0e-10\n\nfunction compute_residual(_q, V, params, cache)\n    # alias on measures\n    dΓ = params.dΓ\n    dΩ = params.dΩ\n    dΓ_perio_x = params.dΓ_perio_x\n    dΓ_perio_y = params.dΓ_perio_y\n\n    q = get_fe_functions(_q)\n\n    # face normals for each face domain (lazy, no computation at this step)\n    n_Γ = get_face_normals(dΓ)\n    nΓ_perio_x = get_face_normals(dΓ_perio_x)\n    nΓ_perio_y = get_face_normals(dΓ_perio_y)\n\n    function l(v)\n        ∫(flux_Ω(q, v))dΩ +\n        -∫(flux_Γ(q, v, n_Γ))dΓ +\n        -∫(flux_Γ(q, v, nΓ_perio_x))dΓ_perio_x +\n        -∫(flux_Γ(q, v, nΓ_perio_y))dΓ_perio_y\n    end\n\n    rhs = assemble_linear(l, V)\n    return rhs\nend\n\n#velocity(h,hu) = (hu/max(h,eps_h))*(h>eps_h)\nvelocity(h, hu) = (hu * 2 * h) / (h * h + max(h * h, 1.0e-6))  #desingularization\n\n\"\"\"\n    flux_Ω(q, v)\n\nCompute volume residual using the lazy-operators approach\n\"\"\"\nflux_Ω(q, v) = _flux_Ω ∘ (q, map(∇, v))\n\nfunction _flux_Ω(q, ∇v)\n    ∇λ_h, ∇λ_hu = ∇v\n    f_h, f_hu = flux_sw(q)\n    return ∇λ_h ⋅ f_h + ∇λ_hu ⊡ f_hu\nend\n\nfunction flux_sw(q)\n    h, hu = q\n    u = velocity(h, hu)\n    huu = hu * transpose(u)\n    g = stateInit.gravity\n    p_grav = 0.5 * g * h * h\n    return h .* u, huu + p_grav * I\nend\n\n\"\"\"\n    flux_Γ(q, v, n)\n\nFlux at the interface is defined by a composition of two functions:\n* the input states which are needed for the flux using operator notations\n* flux_rusanov(q, v, n) defines the face flux for values returned by facevar (as usual)\n\"\"\"\nflux_Γ(q, v, n) = flux_HLL ∘ (side⁻(q), side⁺(q), jump(v), side⁻(n))\n\nfunction flux_HLL(q1, q2, δv, n12)\n    g = stateInit.gravity\n    δv_h, δv_hu = δv\n\n    f_λ = x -> shallow_water_eigval(x, n12, g)\n    flux = _flux_HLL(q1, q2, n12, flux_sw, f_λ)\n\n    flux_h, flux_hu = flux\n    return flux_h ⋅ δv_h + flux_hu ⋅ δv_hu\nend\n\nfunction _flux_rusanov(a, b, n, flux, f_λ)\n    λ = max(f_λ(a), f_λ(b))\n    f_rusanov(a, b, fa, fb) = 0.5 * (dotn(fa + fb, n) - λ * (b - a))\n    map(f_rusanov, a, b, flux(a), flux(b))\nend\n\nfunction _flux_HLL(qL, qR, n, flux, f_λ)\n    λL, λR = f_λ(qL), f_λ(qR)\n    λ⁻ = min(minimum(λL), minimum(λR), zero(λL[1]))\n    λ⁺ = max(maximum(λL), maximum(λR), zero(λL[1]))\n    function f_HLL(qL, qR, fL, fR)\n        if abs(λ⁺ - λ⁻) > 1.0e-12\n            fLn, fRn = dotn(fL, n), dotn(fR, n)\n            f = (λ⁺ * fLn - λ⁻ * fRn + λ⁻ * λ⁺ * (qR - qL)) / (λ⁺ - λ⁻)\n        else\n            f = 0.5 * (fL(qL) + fR(qR))\n        end\n        return f\n    end\n    map(f_HLL, qL, qR, flux(qL), flux(qR))\nend\n\ndotn(f::AbstractVector, n::AbstractVector) = f ⋅ n\ndotn(f::AbstractMatrix, n::AbstractVector) = f * n\n\n\"\"\"\n    flux_Γ_wall(q, v, n)\n\"\"\"\nflux_Γ_wall(q, v, n) = flux_HLL ∘ (side⁻(q), side⁻(q), side⁻(v), side⁻(n))\n\n# function _flux_Γ_wall(q1, v1, n12)\n#     g = stateInit.gravity\n#     h1, hu1 = q1\n#     λ_h1, λ_hu1 = v1\n\n#     flux_h  = zero(h1)\n#     flux_hu = 0.5 * g * h1^2 * n12\n\n#     return λ_h1 * flux_h + λ_hu1 * flux_hu\n# end\n\nfunction rhs(u, U, V, params, cache)\n    rhs = compute_residual(u, V, params, cache)\n    return cache.mass \\ rhs\nend\n\n\"\"\" Inversion of mass matrix (expensive version!!) \"\"\"\nfunction compute_mass_matrix(U, V, dΩ)\n    m(u, v) = ∫(u ⋅ v)dΩ\n    M = assemble_bilinear(m, U, V)\n    return factorize(M)\nend\n\n\"\"\"\n    rk3_ssp(q, f::Function, t, Δt)\n\n`f(q, t)` is the function to integrate.\n\"\"\"\nfunction rk3_ssp(q, f::Function, t, Δt)\n    stepper(q, t) = forward_euler(q, f, t, Δt)\n    _q0 = get_dof_values(q)\n\n    _q1 = stepper(q, Δt)\n\n    set_dof_values!(q, _q1)\n    _q2 = (3 / 4) .* _q0 .+ (1 / 4) .* stepper(q, t + Δt)\n\n    set_dof_values!(q, _q2)\n    _q1 .= (1 / 3) * _q0 .+ (2 / 3) .* stepper(q, t + Δt / 2)\n\n    return _q1\nend\n\n\"\"\"\nTime integration of `f(q, t)` over a timestep `Δt`.\n\"\"\"\nforward_euler(q, f::Function, t, Δt) = get_dof_values(q) .+ Δt .* f(q, t)\n\nmutable struct VtkHandler\n    basename::String\n    basename_residual::String\n    ite::Int\n    VtkHandler(basename) = new(basename, basename * \"_residual\", 0)\nend\n\n\"\"\"\n    Write solution (at cell centers) to vtk\n    Wrapper for `write_vtk`\n\"\"\"\nfunction append_vtk(vtk, mesh, vars, t, params)\n    h, hu = vars\n\n    vtk_degree = maximum(x -> get_degree(Bcube.get_function_space(get_fespace(x))), vars)\n    vtk_degree = max(1, mesh_degree, vtk_degree)\n\n    u = velocity ∘ (h, hu)\n\n    # Write\n    dict_vars_dg = Dict(\n        \"h\" => h,\n        \"hu\" => hu,\n        \"u\" => u,\n        \"h_mean\" => cell_mean(h, params.dΩ),\n        \"hu_mean\" => cell_mean(hu, params.dΩ),\n        \"lim_h\" => params.limh,\n        \"centers\" => MeshCellData(params.xc),\n    )\n\n    write_file(\n        vtk.basename * \"_DG.pvd\",\n        mesh,\n        dict_vars_dg,\n        vtk.ite,\n        t;\n        mesh_degree = vtk_degree,\n        collection_append = vtk.ite > 0,\n    )\n\n    # Update counter\n    vtk.ite += 1\n    return nothing\nend\n\nfunction init!(q, dΩ, initstate)\n    x0 = SA[initstate.x0, initstate.y0]\n    Lstep = initstate.Lstep\n    hstep = initstate.hstep\n\n    f_h(x) = norm(x - x0) < Lstep / 2 ? hstep : 0.0\n    # f_h(x)  = hstep * exp.(-(abs(x[1] - x0) ./ Lstep)^2 ./ 2)\n    f_hu(x) = SA[0.0, 0.0]\n    f = map(PhysicalFunction, (f_h, f_hu))\n    projection_l2!(q, f, dΩ)\n    return nothing\nend\n\nfunction run_simulation(stateInit)\n    # Then generate the mesh of a rectangle using Gmsh and read it\n    tmp_path = \"tmp.msh\"\n    nx, ny, lx, ly = stateInit.nx, stateInit.ny, stateInit.lx, stateInit.ly\n    BcubeGmsh.gen_rectangle_mesh(\n        tmp_path,\n        :quad;\n        nx = nx,\n        ny = ny,\n        lx = lx,\n        ly = ly,\n        xc = 0.0,\n        yc = 0.0,\n    )\n    mesh = read_mesh(tmp_path)\n    rm(tmp_path)\n\n    dimcar = compute_dimcar(mesh)\n\n    # Create a `CellVariable`\n    fs = FunctionSpace(fspace, degree)\n    Q_sca = TrialFESpace(fs, mesh, :discontinuous; size = 1) # DG, scalar\n    Q_vec = TrialFESpace(fs, mesh, :discontinuous; size = 2) # DG, vectoriel\n    V_sca = TestFESpace(Q_sca)\n    V_vec = TestFESpace(Q_vec)\n\n    Q = MultiFESpace(Q_sca, Q_vec)\n    V = MultiFESpace(V_sca, V_vec)\n    q = FEFunction(Q)\n\n    # select an initial configurations:\n    init!(q, mesh, stateInit)\n\n    DMPrelax = DMPcurv₀ .* dimcar .^ 2\n\n    # Then we create a `NamedTuple` to hold the simulation parameters.\n    params = (degree = degree, stateInit = stateInit, DMPrelax = DMPrelax)\n\n    # Define measures for cell and interior face integrations\n    dΩ = Measure(CellDomain(mesh), QUAD)\n    dΓ = Measure(InteriorFaceDomain(mesh), QUAD)\n\n    # Declare boundary conditions and\n    # create associated domains and measures\n    periodicBCType_x = PeriodicBCType(Translation(SA[-lx, 0.0]), (\"East\",), (\"West\",))\n    periodicBCType_y = PeriodicBCType(Translation(SA[0.0, ly]), (\"South\",), (\"North\",))\n    Γ_perio_x = BoundaryFaceDomain(mesh, periodicBCType_x)\n    Γ_perio_y = BoundaryFaceDomain(mesh, periodicBCType_y)\n    dΓ_perio_x = Measure(Γ_perio_x, QUAD)\n    dΓ_perio_y = Measure(Γ_perio_y, QUAD)\n\n    xc = get_cell_centers(mesh) # used for VTK outputs\n\n    params = (\n        params...,\n        dΓ = dΓ,\n        dΩ = dΩ,\n        dΓ_perio_x = dΓ_perio_x,\n        dΓ_perio_y = dΓ_perio_y,\n        xc = xc,\n    )\n\n    # create CellData to store limiter values\n    limh = MeshCellData(ones(ncells(mesh)))\n    limAll = MeshCellData(ones(ncells(mesh)))\n    params = (params..., limh = limh, limAll = limAll)\n\n    # Init vtk handler\n    mkpath(outputpath)\n    vtk = VtkHandler(output)\n\n    # Init time\n    time = 0.0\n\n    # cache mass matrices\n    cache = (\n        mass = compute_mass_matrix(Q, V, dΩ),\n        mass_sca = compute_mass_matrix(Q_sca, V_sca, dΩ),\n        mass_vec = compute_mass_matrix(Q_vec, V_vec, dΩ),\n        cacheCellMean = Bcube.build_cell_mean_cache(q, dΩ),\n    )\n    Δt = Δt₀\n\n    limiter_projection && apply_limitation!(q, params, cache)\n\n    # Save initial solution\n    append_vtk(vtk, mesh, q, time, params)\n\n    # Let's loop to solve the equation.\n    for i in 1:nite\n        Δt = compute_timestep!(q, dΩ, dimcar, CFL)\n\n        ## Infos\n        if (i % Int(max(floor(nite / (nout * 10)), 1)) == 0)\n            println(\"---\")\n            println(\"Iteration \", i)\n            @show Δt, CFL\n        end\n\n        ## Step forward in time\n        _rhs(q, t) = rhs(q, Q, V, params, cache)\n        if timeScheme == :ForwardEuler\n            qnew = forward_euler(q, _rhs, time, Δt)\n        elseif timeScheme == :RK3_SPP\n            qnew = rk3_ssp(q, _rhs, time, Δt)\n        else\n            error(\"Unknown time scheme\")\n        end\n        set_dof_values!(q, qnew)\n\n        limiter_projection && apply_limitation!(q, params, cache)\n\n        time += Δt\n\n        ## Write solution to file (respecting max. number of output)\n        if (i % Int(max(floor(nite / nout), 1)) == 0)\n            append_vtk(vtk, mesh, q, time, params)\n        end\n    end\n\n    append_vtk(vtk, mesh, q, time, params)\n\n    println(\"Benchmarking 'forward_euler':\")\n    _rhs1(q, t) = rhs(q, Q, V, params, cache)\n    @btime forward_euler($q, $_rhs1, $time, $Δt)\n    @btime apply_limitation!($q, $params, $cache)\n    println(\"ndofs total = \", Bcube.get_ndofs(Q))\n\n    Profile.init(; n = 10^7) # returns the current settings\n    Profile.clear()\n    Profile.clear_malloc_data()\n    @profile begin\n        for i in 1:100\n            forward_euler(q, _rhs1, time, Δt)\n            limiter_projection && apply_limitation!(q, params, cache)\n        end\n    end\nend\n\nfunction compute_timestep!(q, dΩ, dimcar, CFL)\n    q_mean = map(Base.Fix2(cell_mean, dΩ), get_fe_functions(q))\n    λ(x...) = shallow_water_maxeigval(x, stateInit.gravity)\n    λmax = map(λ, get_values.(q_mean)...)\n    Δt = CFL * minimum(dimcar ./ λmax)\n    return Δt\nend\n\nfunction shallow_water_maxeigval(q, gravity)\n    h, hu = q\n    u = velocity(h, hu)\n    return norm(u) + √(abs(gravity) * max(h, eps_h))\nend\n\nfunction shallow_water_maxeigval(q, n, gravity)\n    h, hu = q\n    un = velocity(h, hu) ⋅ n\n    return abs(un) + √(abs(gravity) * max(h, eps_h))\nend\n\nfunction shallow_water_eigval(q, n, gravity)\n    h, hu = q\n    un = velocity(h, hu) ⋅ n\n    c = √(abs(gravity) * max(h, eps_h))\n    return un - c, un + c\nend\n\nfunction compute_dimcar(mesh)\n    fs = FunctionSpace(:Lagrange, 0)\n    V = TestFESpace(fs, mesh; size = 1, isContinuous = false)\n\n    # Define measures for cell and interior face integrations\n    dΩ = Measure(CellDomain(mesh), QUAD)\n    dΓ = Measure(InteriorFaceDomain(mesh), QUAD)\n    dΓ_bc = Measure(BoundaryFaceDomain(mesh), QUAD)\n\n    f1 = PhysicalFunction(x -> 1.0)\n    l(v) = ∫(f1 ⋅ v)dΩ\n    l_face(v, dω) = ∫(side⁻(f1) ⋅ side⁻(v) + side⁺(f1) ⋅ side⁺(v))dω\n\n    vol = assemble_linear(l, V)\n    surf = assemble_linear(Base.Fix2(l_face, dΓ), V)\n    assemble_linear!(surf, Base.Fix2(l_face, dΓ_bc), V)\n    return vol ./ surf\nend\n\nfunction apply_limitation!(q, params, cache)\n    h, hu = q\n    dΩ = params.dΩ\n\n    q_mean = cell_mean(q, cache.cacheCellMean)\n\n    _limh, _h_proj = linear_scaling_limiter(\n        h,\n        params.dΩ;\n        bounds = (hmin₀, hmax₀),\n        DMPrelax = params.DMPrelax,\n        mass = cache.mass_sca,\n    )\n    set_dof_values!(h, get_dof_values(_h_proj))\n\n    h_mean, hu_mean, = q_mean\n    limited_var(a, a̅, lim_a) = a̅ + lim_a * (a - a̅)\n    projection_l2!(hu, limited_var(hu, hu_mean, _limh), params.dΩ; mass = cache.mass_vec)\n\n    if eltype(_limh) == eltype(params.limh) # skip Dual number case\n        set_values!(params.limh, get_values(_limh))\n    end\n    return nothing\nend\n\n# Function-space get_degree (Taylor(0) = first order Finite Volume)\nconst degree = 1\nconst mesh_degree = 1\nconst fspace = Bcube.Lagrange(:Lobatto) #:Lagrange\n# The degree of quadrature is chosen such as mass matrix are integrated exactly.\nconst QUAD = Quadrature(QuadratureLobatto(), max(1, 2 * degree))\nconst limiter_projection = true\nconst hmin₀ = 1.e-8\nconst hmax₀ = 1.0e10\nconst DMPcurv₀ = 10.0\n\nconst stateInit = (\n    gravity = 9.81,\n    nx = 65,\n    ny = 65,\n    lx = 2.0,\n    ly = 2.0,\n    x0 = 0.0,\n    y0 = 0.0,\n    Lstep = 1.0,\n    hstep = 2.5,\n)\nconst nite = 5000 #300000 # Number of time iteration(s)\nconst timeScheme = :ForwardEuler # :ForwardEuler, :RK3_SPP\nconst CFL = 0.4 / (2 * degree + 1)\nconst nout = 100 # Number of time steps to save\nconst outputpath = joinpath(@__DIR__, \"../../../myout/shallow_water/\")\nconst output = outputpath * \"sw_deg$degree\"\nconst Δt₀ = 1.e-7\n\n@show get_degree(QUAD)\n\nmkpath(outputpath)\nrun_simulation(stateInit)\n\nend #hide","category":"page"},{"location":"example/linear_elasticity/#Linear-elasticity","page":"Linear elasticity","title":"Linear elasticity","text":"","category":"section"},{"location":"example/linear_elasticity/","page":"Linear elasticity","title":"Linear elasticity","text":"module linear_elasticity #hide\nprintln(\"Running linear elasticity API example...\") #hide\n\n# # Linear elasticity\n\nconst dir = string(@__DIR__, \"/\") # bcube/example dir\nusing Bcube\nusing BcubeVTK\nusing LinearAlgebra\nusing StaticArrays\n\n# function space (here we shall use Lagrange P1 elements) and quadrature degree.\nconst fspace = :Lagrange\nconst degree = 1 # FunctionSpace degree\nconst degquad = 2 * degree + 1\n\n# Input and output paths\nconst outputpath = dir * \"../../../myout/linear_elasticity/\"\nconst meshpath = dir * \"../../../input/mesh/domainElast_tri.msh\"\n\n# Time stepping scheme params\nconst α = 0.05\nconst γ = 0.5 + α\nconst β = 0.25 * (1.0 + α)^2\n\n# Material parameters (Young's modulus, Poisson coefficient and deduced Lamé coefficients)\nconst ρ = 2500.0\nconst E = 200.0e9\nconst ν = 0.3\nconst λ = E * ν / ((1.0 + ν) * (1.0 - 2.0 * ν))\nconst μ = E / (2.0 * (1.0 + ν))\n\n# Strain tensor and stress tensor (Hooke's law)\nϵ(u) = 0.5 * (∇(u) + transpose(∇(u)))\nσ(u) = λ * tr(ϵ(u)) * I + 2 * μ * ϵ(u)\n\nπ(u, v) = σ(u) ⊡ ϵ(v) # with the chosen contraction convention ϵ should be transposed, but as it is symmetric the expression remains correct\n\n# materialize for identity operator\nBcube.materialize(A::LinearAlgebra.UniformScaling, B) = A\n\n# Function that runs the steady case:\nfunction run_steady()\n    # read mesh, the second argument specifies the spatial dimension\n    mesh = read_mesh(meshpath, 2)\n\n    fs = FunctionSpace(fspace, degree)\n    U_vec = TrialFESpace(\n        fs,\n        mesh,\n        Dict(\"West\" => SA[0.0, 0.0], \"East\" => SA[1.0, 0.0]);\n        size = 2,\n    )\n    V_vec = TestFESpace(U_vec)\n\n    # Define measures for cell\n    dΩ = Measure(CellDomain(mesh), degquad)\n\n    # no volume force term\n    f = PhysicalFunction(x -> SA[0.0, 0.0])\n\n    # definition of bilinear and linear forms\n    a(u, v) = ∫(π(u, v))dΩ\n    l(v) = ∫(f ⋅ v)dΩ\n\n    # solve using AffineFESystem\n    sys = Bcube.AffineFESystem(a, l, U_vec, V_vec)\n    ϕ = Bcube.solve(sys)\n\n    # Write the obtained FE solution\n    dict_vars = Dict(\"Displacement\" => ϕ)\n    mkpath(outputpath)\n    write_file(outputpath * \"result_elasticity.pvd\", mesh, dict_vars)\nend\n\n# Function that performs a time step using a Newmark α-HHT scheme\n# The scheme updates the acceleration G, the velocity V and the displacement U using the following formulas:\n#\n# M G +(1-α)A U + αA U0 = (1-α) L + α L0 = L (because here L is time independent)\n# V = V0 + (1-γ) Δt G0 + γ Δt G\n# U = U0 + Δt V0 + (0.5-β)*Δt^2 G0 + β Δt^2 G\n#\n# G is then computed by solving the linear system obtained by inserting the expressions for U and V in the equation for G.\nfunction Newmark_α_HHT(dt, L, A, Mat, U0, V0, G0)\n    L1 = L - α * A * U0\n    L2 = -(1.0 - α) * (A * U0 + dt * A * V0 + (0.5 - β) * dt * dt * A * G0)\n    RHS = L1 .+ L2\n\n    G = Mat \\ RHS\n    V = V0 + (1.0 - γ) * dt * G0 + γ * dt * G\n    U = U0 + dt * V0 + (0.5 - β) * dt * dt * G0 + β * dt * dt * G\n\n    return U, V, G\nend\n\n# Function that runs the unsteady case:\nfunction run_unsteady()\n    # Read the mesh\n    mesh = read_mesh(meshpath)\n\n    fs = FunctionSpace(fspace, degree)\n    U_vec = TrialFESpace(fs, mesh, Dict(\"West\" => SA[0.0, 0.0]); size = 2)\n    V_vec = TestFESpace(U_vec)\n\n    # Define measures for cell\n    dΩ = Measure(CellDomain(mesh), degquad)\n    Γ = BoundaryFaceDomain(mesh, (\"East\",))\n    dΓ = Measure(Γ, degquad)\n\n    # surface force to be applied on East boundary\n    f = PhysicalFunction(x -> SA[100000.0, 1000.0])\n\n    # Definition of bilinear and linear forms\n    a(u, v) = ∫(π(u, v))dΩ\n    m(u, v) = ∫(ρ * u ⋅ v)dΩ\n    l(v) = ∫(side⁻(f) ⋅ side⁻(v))dΓ\n\n    # Assemble matrices and vector\n    M = assemble_bilinear(m, U_vec, V_vec)\n    A = assemble_bilinear(a, U_vec, V_vec)\n    L = assemble_linear(l, V_vec)\n\n    # Apply homogeneous dirichlet on A and b\n    Bcube.apply_homogeneous_dirichlet_to_vector!(L, U_vec, V_vec, mesh)\n    Bcube.apply_dirichlet_to_matrix!((A, M), U_vec, V_vec, mesh)\n\n    # Initialize solution\n    ϕ = FEFunction(U_vec, 0.0)\n    U0 = zeros(Bcube.get_ndofs(U_vec))\n    V0 = zeros(Bcube.get_ndofs(U_vec))\n    G0 = zeros(Bcube.get_ndofs(U_vec))\n\n    # Write initial solution\n    # Write the obtained FE solution\n    dict_vars = Dict(\"Displacement\" => ϕ)\n    mkpath(outputpath)\n    write_file(outputpath * \"result_elasticity.pvd\", mesh, dict_vars, 0, 0.0)\n\n    # Time loop\n    totalTime = 1.0e-3\n    Δt = 1.0e-6\n    itime = 0\n    t = 0.0\n\n    # Matrix for time stepping\n    Mat = factorize(M + (1.0 - α) * (β * Δt * Δt * A))\n\n    while t <= totalTime\n        t += Δt\n        itime = itime + 1\n        @show t, itime\n\n        # solve time step\n        U, V, G = Newmark_α_HHT(Δt, L, A, Mat, U0, V0, G0)\n\n        # Update solution\n        U0 .= U\n        V0 .= V\n        G0 .= G\n\n        set_dof_values!(ϕ, U)\n\n        # Write solution\n        if itime % 10 == 0\n            # Write the obtained FE solution\n            dict_vars = Dict(\"Displacement\" => ϕ)\n            write_file(\n                outputpath * \"result_elasticity.pvd\",\n                mesh,\n                dict_vars,\n                itime,\n                t;\n                collection_append = true,\n            )\n            # In order to use the warp function in paraview (solid is deformed using the displacement field)\n            # the calculator filter has to be used with the following formula to reconstruct a 3D displacement field\n            # with 0 z-component: Displacement_X*iHat+Displacement_Y*jHat+0.0*kHat\n        end\n    end\nend\n\n#run_steady()\nrun_unsteady()\n\nend #hide","category":"page"},{"location":"example/heat_equation_two_layers/#Heat-equation-with-two-layers","page":"Heat equation with two layers","title":"Heat equation with two layers","text":"","category":"section"},{"location":"example/heat_equation_two_layers/","page":"Heat equation with two layers","title":"Heat equation with two layers","text":"module HeatEquationTwoLayers #hide\nprintln(\"Running heat equation two layers example...\") #hide\n# # Heat equation\n# # Theory\n# This example shows how to solve the heat equation with eventually variable physical properties in steady and unsteady formulations:\n# ```math\n#   \\rho C_p \\partial_t u - \\nabla . ( \\lambda \\nabla u) = f\n# ```\n# We shall assume that $$f, \\, \\rho, \\, C_p, \\, \\lambda \\, \\in L^2(\\Omega)$$. The weak form of the problem is given by: find $$ u \\in \\tilde{H}^1_0(\\Omega)$$\n# (there will be at least one Dirichlet boundary condition) such that:\n# ```math\n#   \\forall v \\in  \\tilde{H}^1_0(\\Omega), \\, \\, \\, \\underbrace{\\int_\\Omega \\partial_t u . v dx}_{m(\\partial_t u,v)} + \\underbrace{\\int_\\Omega \\nabla u . \\nabla v dx}_{a(u,v)} = \\underbrace{\\int_\\Omega f v dx}_{l(v)}\n# ```\n# To numerically solve this problem we seek an approximate solution using Lagrange $$P^1$$ or $$P^2$$ elements.\n# Here we assume that the domain can be split into two domains having different material properties.\n\nconst dir = joinpath(@__DIR__, \"..\", \"..\", \"..\") # BcubeTutorials dir\nusing Bcube\nusing BcubeVTK\nusing LinearAlgebra\nusing Test #src\n\nfunction T_analytical_two_layers(x, λ1, λ2, T0, T1, L)\n    if x < 0.5 * L\n        T = 2.0 * (λ2 / (λ1 + λ2)) * ((T1 - T0) / L) * x + T0\n    else\n        T = 2.0 * (λ1 / (λ1 + λ2)) * ((T1 - T0) / L) * (x - L) + T1\n    end\n    return T\nend\n\nconst outputpath = joinpath(dir, \"myout\", \"heat_equation_two_layers\")\nmkpath(outputpath)\n\n\"\"\"\nTwo layers case using MeshCellData that depends on the subdomain. A unique assembly is then performed over the whole mesh\n(by opposition to method2)\n\"\"\"\nfunction run_steady_two_layers_method1(; degree)\n    println(\"Running steady two layers case - method 1\")\n    T0 = 260.0\n    T1 = 300.0\n    λ1 = 150.0\n    λ2 = 10.0\n\n    # Read mesh\n    mesh = read_mesh(joinpath(dir, \"input\", \"mesh\", \"domainTwoLayer_tri.msh\"))\n\n    fs = FunctionSpace(:Lagrange, degree)\n    U = TrialFESpace(fs, mesh, Dict(\"West\" => T0, \"East\" => T1))\n    V = TestFESpace(U)\n\n    # Define measures for cell integration\n    dΩ = Measure(CellDomain(mesh), 2 * degree + 1)\n\n    material_1 = Bcube.get_zone_element_indices(mesh, \"Domain_1\")\n    material_2 = Bcube.get_zone_element_indices(mesh, \"Domain_2\")\n\n    λ = zeros(ncells(mesh))\n    λ[material_1] .= λ1\n    λ[material_2] .= λ2\n\n    qtmp = zeros(ncells(mesh))\n\n    q = MeshCellData(qtmp)\n    η = MeshCellData(λ)\n\n    # Compute matrices associated to bilinear and linear forms\n    a(u, v) = ∫(η * ∇(u) ⋅ ∇(v))dΩ\n    l(v) = ∫(q * v)dΩ\n\n    system = AffineFESystem(a, l, U, V)\n    ϕ = Bcube.solve(system)\n\n    T_analytical = PhysicalFunction(x -> T_analytical_two_layers(x[1], λ1, λ2, T0, T1, 0.2))\n\n    Tcn = var_on_centers(ϕ, mesh)\n    Tca = var_on_centers(T_analytical, mesh)\n    dict_vars =\n        Dict(\"Temperature\" => MeshCellData(Tcn), \"Temperature_a\" => MeshCellData(Tca))\n    write_file(\n        joinpath(outputpath, \"result_steady_heat_equation_two_layers_method1.pvd\"),\n        mesh,\n        dict_vars,\n    )\n\n    err = norm(Tca .- Tcn, Inf) / norm(Tca, Inf)\n    @show err\n\n    if get(ENV, \"TestMode\", \"false\") == \"true\" #src\n        @test err < 2.1e-5                     #src\n    end                                        #src\nend\n\n\"\"\"\nTwo layers case using subdomain integration.\n\"\"\"\nfunction run_steady_two_layers_method2(; degree)\n    println(\"Running steady two layers case - method 2\")\n    T0 = 260.0\n    T1 = 300.0\n    λ1 = 150.0\n    λ2 = 10.0\n\n    # Read mesh\n    mesh = read_mesh(joinpath(dir, \"input\", \"mesh\", \"domainTwoLayer_tri.msh\"))\n\n    fs = FunctionSpace(:Lagrange, degree)\n    U = TrialFESpace(fs, mesh, Dict(\"West\" => T0, \"East\" => T1))\n    V = TestFESpace(U)\n\n    material_1 = Bcube.get_zone_element_indices(mesh, \"Domain_1\")\n    material_2 = Bcube.get_zone_element_indices(mesh, \"Domain_2\")\n\n    # Define measures for cell and interior face integrations\n\n    dΩ = Measure(CellDomain(mesh), 2 * degree + 1)\n    dΩ1 = Measure(CellDomain(mesh, material_1), 2 * degree + 1)\n    dΩ2 = Measure(CellDomain(mesh, material_2), 2 * degree + 1)\n\n    qtmp = zeros(ncells(mesh))\n\n    q = MeshCellData(qtmp)\n\n    # compute matrices associated to bilinear and linear forms\n    a(u, v) = ∫(λ1 * ∇(u) ⋅ ∇(v))dΩ1 + ∫(λ2 * ∇(u) ⋅ ∇(v))dΩ2\n    l(v) = ∫(q * v)dΩ\n\n    system = AffineFESystem(a, l, U, V)\n    ϕ = Bcube.solve(system)\n\n    T_analytical = PhysicalFunction(x -> T_analytical_two_layers(x[1], λ1, λ2, T0, T1, 0.2))\n\n    Tcn = var_on_centers(ϕ, mesh)\n    Tca = var_on_centers(T_analytical, mesh)\n    dict_vars =\n        Dict(\"Temperature\" => MeshCellData(Tcn), \"Temperature_a\" => MeshCellData(Tca))\n    write_file(\n        joinpath(outputpath, \"result_steady_heat_equation_two_layers_method2.pvd\"),\n        mesh,\n        dict_vars,\n    )\n\n    err = norm(Tca .- Tcn, Inf) / norm(Tca, Inf)\n    @show err\n\n    if get(ENV, \"TestMode\", \"false\") == \"true\" #src\n        @test err < 2.1e-5                     #src\n    end                                        #src\nend\n\nrun_steady_two_layers_method1(; degree = 2)\nrun_steady_two_layers_method2(; degree = 2)\n\nend #hide","category":"page"},{"location":"example/transport_supg/#Linear-transport-(FEM-SUPG)","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"","category":"section"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"This example demonstrates the application of the FEM Streamline Upwind Petrov-Galerkin method to a linear transport equation.","category":"page"},{"location":"example/transport_supg/#Maths","page":"Linear transport (FEM-SUPG)","title":"Maths","text":"","category":"section"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"There are several ways to present the method, here is one adapted from the book of Zienkiwicz et al. (The Finite Element Method for Fluid Dynamics).","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"We consider the following transport equation:","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"beginaligned\n  partial_t u + c cdot nabla u = 0 \n  u(0 t) = u_in(t)\nendaligned","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"where c is the transport velocity. To ease the demonstration, we restrict ourselves to a 1D equation at a constant velocity : partial_t u + c partial_x u = 0. Let's introduce chi(t) a (characteristic) curve corresponding to this equation, then","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"dfracdudt = dfracpartial chipartial t dfracpartial upartial x + dfracpartial upartial t","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"so that with partial chi  partial t = c we have that dudt is zero along the characteristic curve. Let's note u^n(x) the solution at point x and time n Delta t. Let's also note delta = c Delta t and apply a first order Taylor expansion in time for dudt:","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"dfrac1Delta t(u^n+1(x) - u^n(x - delta)) = 0","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"The x - delta comes from the fact that we are differentiating along the characteristic curve. Then, a Taylor expansion in space of u^n(x - delta) leads to","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"u^n(x - delta) = u^n(x) - delta partial_x u^n + dfracdelta^22 partial^2_x u^n","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"The time-space discretization now reads","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"u^n+1 = u^n - delta partial_x u^n + dfracdelta^22 partial^2_x u^n","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"To compute the weak form, we multiply by a test function v and integrate over the whole domain. An integration by parts is performed on the last term, ignoring boundary terms for this specific example.","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"beginaligned\n   int_Omega u^n+1 v = int_Omega u^n v - int_Omega delta (partial_x u^n)v + int_Omega dfracdelta^22 (partial^2_x u^n) v \n   int_Omega u^n+1 v = int_Omega u^n v - int_Omega delta (partial_x u^n)v - int_Omega dfracdelta^22 partial_x u^n partial_x v \n   int_Omega u^n+1 v = int_Omega u^n v - int_Omega delta (partial_x u^n) left(v +dfracdelta2 partial_x v right) \nendaligned","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Hence, the weak formulation is quite straigthforward, it simply consists in replacing the test function v in the advection term by v + cDelta t partial_x v  2.","category":"page"},{"location":"example/transport_supg/#Code","page":"Linear transport (FEM-SUPG)","title":"Code","text":"","category":"section"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"using Bcube\nusing LinearAlgebra\nusing StaticArrays\nusing Plots\n\nconst degree = 1 # Function-space degree (Taylor(0) = first order Finite Volume)\nconst nite = 250 # Number of time iteration(s)\nconst CFL = 0.5 # CFL number\nconst nx = 101 # Number of nodes in the x-direction\nconst ny = 41 # Number of nodes in the y-direction\nconst lx = 1.0 # Domain width\nconst ly = 2.0 # Domain height\nconst c = SA[1.0] # Transport velocity\n\n@assert degree >= 1 \"Cannot apply Dirichlet when degree = 0!\"","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Build mesh, and prepare output","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"mesh = line_mesh(nx; xmax = lx, names = (\"West\", \"East\"))\n\nout_dir = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"myout\", \"linear_transport\")\nmkpath(out_dir)","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Time step defined by a CFL condition","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"const Δt = CFL * min(lx / (nx - 1), ly / (ny - 1)) / norm(c)\nt = 0.0","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Inlet boundary condition. Use f_west(x, t) = 1.0 for a square.","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"f_west(x, t) = sin(10 * t) # better start with 0 at t=0","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Function space, trial and test FESpace, with the boundary condition","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"fs = FunctionSpace(:Lagrange, degree)\nU = TrialFESpace(fs, mesh, Dict(\"West\" => f_west))\nV = TestFESpace(U)","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Measure for domain discretization","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"dΩ = Measure(CellDomain(mesh), 2 * degree + 1)","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Compute 'h', the cell characteristic length","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"vol = MeshCellData(Bcube.compute(∫(PhysicalFunction(x -> 1))dΩ))","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"SUPG test function : two equivalent formulae: $ \\tilde{v} = v + \\dfrac{\\Delta t}{2} c \\cdot \\nabla v$ or $ \\tilde{v} = v + \\alpha \\dfrac{\\Delta x}{2} \\dfrac{c}{|c|} \\cdot \\nabla v$ where alpha = c Delta t  Delta x is the CFL number.","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"supg(v) = v + Δt / 2 * c ⋅ ∇(v)\n# supg(v) = v + CFL * h / (2 * norm(c)) * (c ⋅ ∇(v))","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Bilinear forms (mass and advection) definitions and assembly","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"a(u, v) = ∫(u ⋅ v)dΩ # Mass bilinear form : no supg\nb(u, v) = ∫((c ⋅ ∇(u)) ⋅ supg(v))dΩ # Convection bilinear form\n\nA = assemble_bilinear(a, U, V)\nB = assemble_bilinear(b, U, V)\nM = I - Δt * inv(Matrix(A)) * B #WARNING : really expensive !!!","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Build FE functions : one for the computed solution, one for the reference solution interpolated on the FESpace (that the best we can obtain!)","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"u = FEFunction(U)\napply_dirichlet_to_vector!(u.dofValues, U, V, mesh, t)\n\nu_ref = FEFunction(U)","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Prepare animation. Since the mesh and the FESpace are \"trivial\", we directly extract the mesh coordinates into a vector and the dof values are in the same order.","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"anim = Animation()\nx = [get_coords(node, 1) for node in get_nodes(mesh)]","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Let's loop","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"for i in 1:nite\n    global t\n\n    # Update time\n    t += Δt\n\n    # Update solution\n    u.dofValues .= M * u.dofValues\n\n    # Apply bnd condition : we can also set M[1,:] = [1, 0...]\n    apply_dirichlet_to_vector!(u.dofValues, U, V, mesh, t)\n\n    # Evaluate and project reference solution on FESpace\n    projection_l2!(\n        u_ref,\n        PhysicalFunction(x -> (x[1] - c[1] * t) > 0 ? 0.0 : f_west(0, t - x[1] / c[1])),\n        mesh,\n    )\n\n    # Build animation\n    plt = plot(x, u.dofValues; label = \"u\", xlabel = \"x\")\n    plot!(x, u_ref.dofValues; label = \"u_ref\", ls = :dot)\n    frame(anim, plt)\nend","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"Here is the output animation","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"g = gif(anim, joinpath(out_dir, \"transport_supg.gif\"))\ndisplay(g)","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"(Image: )","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"","category":"page"},{"location":"example/transport_supg/","page":"Linear transport (FEM-SUPG)","title":"Linear transport (FEM-SUPG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example/heat_equation_sphere/#Heat-equation-on-a-sphere","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"","category":"section"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"Adapted from https://www.chebfun.org/examples/sphere/SphereHeatConduction.html. The equation solved on the sphere is","category":"page"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"  partial_t T = alpha Delta_Gamma T","category":"page"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"The temperature is initialized by the following sum of spherical harmonic:","category":"page"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"  u(lambda theta) = Y^0_6(lambda theta) + sqrt1411Y^6_6(lambdatheta)","category":"page"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"where lambda and theta are two angles parametrizing the sphere. Hence an analytical solution can be found : u(lambdatheta t) = e^-42 alpha t u_0(lambda theta).","category":"page"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"The following animation is obtained after running the simulation:","category":"page"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"(Image: )","category":"page"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"using Bcube\nusing BcubeVTK\nusing BcubeGmsh\nusing LinearAlgebra\nusing StaticArrays\nusing FastTransforms\nusing Random\nusing ProgressMeter\n\n\"\"\"\nFrom wikipedia (physics)\n\nOther mathematical valid possibilites:\n* CoordinateTransformations: https://github.com/JuliaGeometry/CoordinateTransformations.jl/blob/b97c74a35c6835f6b015440cb4af6298824dbe1d/src/coordinatesystems.jl#L161\n* Custom : θ = atan(z, sqrt(x^2 + y^2)), ϕ = atan(y, x)\n\"\"\"\nfunction cart2sphere(xyz)\n    x, y, z = xyz\n\n    r = norm(xyz)\n\n    θ = acos(z / r)\n    ϕ = sign(y) * acos(x / sqrt(x^2 + y^2))\n\n    return SA[r, θ, ϕ]\nend\n\nfunction rotMat(θx, θy, θz)\n    Rx = @SMatrix[\n        1.0 0.0 0.0\n        0.0 cos(θx) sin(θx)\n        0.0 (-sin(θx)) cos(θx)\n    ]\n    Ry = @SMatrix[\n        cos(θy) 0.0 (-sin(θy))\n        0.0 1.0 0.0\n        sin(θy) 0.0 cos(θy)\n    ]\n    Rz = @SMatrix[\n        cos(θz) sin(θz) 0.0\n        -sin(θz) cos(θz) 0.0\n        0.0 0.0 1.0\n    ]\n    return Rx * Ry * Rz\nend\n\nmutable struct VtkHandler\n    basename::Any\n    ite::Any\n    mesh::Any\n    θ::Any\n    θ_centers::Any\n    ϕ::Any\n    ϕ_centers::Any\n    ν::Any\n    ν_centers::Any\n    function VtkHandler(basename, mesh)\n        θ = PhysicalFunction(x -> cart2sphere(x)[2])\n        θ_centers = MeshCellData(var_on_centers(θ, mesh))\n\n        ϕ = PhysicalFunction(x -> cart2sphere(x)[3])\n        ϕ_centers = MeshCellData(var_on_centers(ϕ, mesh))\n\n        ν = get_cell_normals(CellDomain(mesh))\n        ν_centers = var_on_centers(ν, mesh)\n        _ν_centers = MeshCellData([SA[ν_centers[i, :]...] for i in 1:ncells(mesh)])\n\n        new(basename, 0, mesh, θ, θ_centers, ϕ, ϕ_centers, ν, _ν_centers)\n    end\nend\n\nfunction append_vtk(vtk, u::Bcube.AbstractFEFunction, t)\n    values_centers = MeshCellData(var_on_centers(u, vtk.mesh))\n\n    # Write\n    write_file(\n        vtk.basename,\n        vtk.mesh,\n        Dict(\n            \"u_centers\" => values_centers,\n            \"u_vertices\" => u,\n            \"θ_centers\" => vtk.θ_centers,\n            \"θ_vertices\" => vtk.θ,\n            \"ϕ_centers\" => vtk.ϕ_centers,\n            \"ϕ_vertices\" => vtk.ϕ,\n            \"ν_centers\" => vtk.ν_centers,\n            \"ν_vertices\" => vtk.ν,\n        ),\n        vtk.ite,\n        t;\n        collection_append = vtk.ite > 0,\n    )\n\n    # Update counter\n    vtk.ite += 1\nend\n\nfunction run(;\n    α = 1.0 / 42,\n    degree = 1,\n    tfinal = 1,\n    nout = 100,\n    lc = 1e-1,\n    CFL = 0.5,\n    vtk_output = true,\n)\n\n    # Settings\n    out_dir = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"myout\", \"heat_eqn_sphere\")\n    mkpath(out_dir)\n\n    # Mesh\n    mesh_path = joinpath(out_dir, \"mesh.msh\")\n    BcubeGmsh.gen_sphere_mesh(mesh_path; radius = 1.0, lc = lc)\n    mesh = read_mesh(mesh_path)\n    rng = MersenneTwister(0)\n    R = rotMat(rand(rng, 3)...)\n    transform!(mesh, x -> R * x) # rotate to avoid being \"aligned\" with an axis\n\n    # Domain\n    dΩ = Measure(CellDomain(mesh), 2 * degree + 1)\n\n    # Prepare output\n    vtk = VtkHandler(joinpath(out_dir, \"result_d$(degree).pvd\"), mesh)\n\n    # Discretization\n    U = TrialFESpace(FunctionSpace(:Lagrange, degree), mesh)\n    V = TestFESpace(U)\n    u = FEFunction(U)\n\n    # Display infos\n    println(\"degree = $degree, CFL = $CFL, lc = $lc, ndofs = $(get_ndofs(U))\")\n\n    # Init\n    u0 = PhysicalFunction(\n        x -> begin\n            _r, _θ, _ϕ = cart2sphere(x)\n            return sphevaluate(_θ, _ϕ, 6, 0) + √(14 / 11) * sphevaluate(_θ, _ϕ, 6, 5)\n        end,\n    )\n    projection_l2!(u, u0, mesh)\n\n    # Bilinear forms\n    m(u, v) = ∫(u ⋅ v)dΩ\n    a(u, v) = ∫(∇ₛ(u) ⋅ ∇ₛ(v))dΩ\n\n    # Assemble\n    M = assemble_bilinear(m, U, V)\n    K = assemble_bilinear(a, U, V)\n\n    # Time loop\n    Δt = CFL * lc^2 / α\n    nite = floor(Int, tfinal / Δt)\n    _nout = min(nite, nout)\n    t = 0.0\n    b = Bcube.allocate_dofs(U)\n    vtk_output && append_vtk(vtk, u, t)\n    progress = Progress(nite)\n    for ite in 1:nite\n        b .= (M + Δt * α * K) \\ (M * get_dof_values(u))\n        set_dof_values!(u, b)\n\n        t += Δt\n        next!(progress)\n\n        # Output results\n        if ite % (nite ÷ _nout) == 0\n            vtk_output && append_vtk(vtk, u, t)\n        end\n    end\n\n    # Compute L2 error with the analytical solution\n    utrue = exp(-42 * α * t) * u0\n    errL2 = sum(Bcube.compute(∫((utrue - u)^2)dΩ))\n    return get_ndofs(U), errL2\nend\n\nndofs, errL2 = run(;\n    degree = 1,\n    α = 1.0 / 42,\n    tfinal = 1,\n    CFL = 0.5,\n    nout = 100,\n    lc = 4e-2,\n    vtk_output = true,\n)\n@show errL2\n\n","category":"page"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"","category":"page"},{"location":"example/heat_equation_sphere/","page":"Heat equation on a sphere","title":"Heat equation on a sphere","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example/euler_naca_steady/#Euler-equations-on-a-NACA0012","page":"Euler equations on a NACA0012","title":"Euler equations on a NACA0012","text":"","category":"section"},{"location":"example/euler_naca_steady/","page":"Euler equations on a NACA0012","title":"Euler equations on a NACA0012","text":"module EulerNacaSteady #hide\nprintln(\"Running euler_naca_steady example...\") #hide\n# # Solve Euler equation around a NACA0012 airfoil\n\nusing Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing WriteVTK # for write_vtk_bnd_discontinuous (VTKPointData, VTKCellData)\nusing LinearAlgebra\nusing StaticArrays\nusing BenchmarkTools\nusing Roots\nusing SparseArrays\nusing Profile\nusing InteractiveUtils\nusing DifferentialEquations\nusing Symbolics\nusing SparseDiffTools\n\nconst dir = string(@__DIR__, \"/\")\n\nfunction compute_residual(qdof, Q, V, params)\n    q = (FEFunction(Q, qdof)...,)\n\n    # alias on measures\n    dΓ = params.dΓ\n    dΩ = params.dΩ\n    dΓ_wall = params.dΓ_wall\n    dΓ_farfield = params.dΓ_farfield\n\n    # Allocate rhs vectors\n    b_vol = zero(qdof)\n    b_fac = zero(qdof)\n\n    # compute volume residuals\n    l_vol(v) = ∫(flux_Ω(q, v))dΩ\n    assemble_linear!(b_vol, l_vol, V)\n\n    # face normals for each face domain (lazy, no computation at this step)\n    nΓ = get_face_normals(dΓ)\n    nΓ_wall = get_face_normals(dΓ_wall)\n    nΓ_farfield = get_face_normals(dΓ_farfield)\n\n    # flux residuals from interior faces for all variables\n    l_Γ(v) = ∫(flux_Γ(q, v, nΓ))dΓ\n    assemble_linear!(b_fac, l_Γ, V)\n\n    # flux residuals from bc faces for all variables\n    l_Γ_wall(v) = ∫(flux_Γ_wall(q, v, nΓ_wall))dΓ_wall\n    l_Γ_farfield(v) = ∫(flux_Γ_farfield(q, v, nΓ_farfield))dΓ_farfield\n    assemble_linear!(b_fac, l_Γ_wall, V)\n    assemble_linear!(b_fac, l_Γ_farfield, V)\n    dQ = b_vol .- b_fac\n\n    return dQ\nend\n\n\"\"\"\n    flux_Ω(q, v)\n\nCompute volume residual using the lazy-operators approach\n\"\"\"\nflux_Ω(q, v) = _flux_Ω ∘ (q, map(∇, v))\n\nfunction _flux_Ω(q, ∇v)\n    ρ, ρu, ρE = q\n    ∇λ_ρ, ∇λ_ρu, ∇λ_ρE = ∇v\n    γ = stateInit.γ\n\n    vel = ρu ./ ρ\n    ρuu = ρu * transpose(vel)\n    p = pressure(ρ, ρu, ρE, γ)\n\n    flux_ρ  = ρu\n    flux_ρu = ρuu + p * I\n    flux_ρE = (ρE + p) .* vel\n\n    return return ∇λ_ρ ⋅ flux_ρ + ∇λ_ρu ⊡ flux_ρu + ∇λ_ρE ⋅ flux_ρE\nend\n\n\"\"\"\n    flux_Γ(q, v, n)\n\nFlux at the interface is defined by a composition of two functions:\n* the input states at face sides which are needed for the riemann flux\n* `flux_roe` defines the Riemann flux (as usual)\n\"\"\"\nflux_Γ(q, v, n) = flux_roe ∘ (side⁻(q), side⁺(q), jump(v), side⁻(n))\n\n\"\"\"\n    flux_roe(q⁻, q⁺, δv, n)\n\"\"\"\nfunction flux_roe(q⁻, q⁺, δv, n)\n    γ = stateInit.γ\n    nx, ny = n\n    ρ1, (ρu1, ρv1), ρE1 = q⁻\n    ρ2, (ρu2, ρv2), ρE2 = q⁺\n    δλ_ρ1, δλ_ρu1, δλ_ρE1 = δv\n\n    ρ1 = max(eps(ρ1), ρ1)\n    ρ2 = max(eps(ρ2), ρ2)\n\n    # Closure\n    u1 = ρu1 / ρ1\n    v1 = ρv1 / ρ1\n    u2 = ρu2 / ρ2\n    v2 = ρv2 / ρ2\n    p1 = pressure(ρ1, SA[ρu1, ρv1], ρE1, γ)\n    p2 = pressure(ρ2, SA[ρu2, ρv2], ρE2, γ)\n\n    H2 = (γ / (γ - 1)) * p2 / ρ2 + (u2 * u2 + v2 * v2) / 2.0\n    H1 = (γ / (γ - 1)) * p1 / ρ1 + (u1 * u1 + v1 * v1) / 2.0\n\n    R = √(ρ1 / ρ2)\n    invR1 = 1.0 / (R + 1)\n    uAv = (R * u1 + u2) * invR1\n    vAv = (R * v1 + v2) * invR1\n    Hav = (R * H1 + H2) * invR1\n    cAv = √(abs((γ - 1) * (Hav - (uAv * uAv + vAv * vAv) / 2.0)))\n    ecAv = (uAv * uAv + vAv * vAv) / 2.0\n\n    λ1 = nx * uAv + ny * vAv\n    λ3 = λ1 + cAv\n    λ4 = λ1 - cAv\n\n    d1 = ρ1 - ρ2\n    d2 = ρ1 * u1 - ρ2 * u2\n    d3 = ρ1 * v1 - ρ2 * v2\n    d4 = ρE1 - ρE2\n\n    # computation of the centered part of the flux\n    flux_ρ  = nx * ρ2 * u2 + ny * ρ2 * v2\n    flux_ρu = nx * p2 + flux_ρ * u2\n    flux_ρv = ny * p2 + flux_ρ * v2\n    flux_ρE = H2 * flux_ρ\n\n    # Temp variables\n    rc1 = (γ - 1) / cAv\n    rc2 = (γ - 1) / cAv / cAv\n    uq41 = ecAv / cAv + cAv / (γ - 1)\n    uq42 = nx * uAv + ny * vAv\n\n    fdc1 = max(λ1, 0.0) * (d1 + rc2 * (-ecAv * d1 + uAv * d2 + vAv * d3 - d4))\n    fdc2 = max(λ1, 0.0) * ((nx * vAv - ny * uAv) * d1 + ny * d2 - nx * d3)\n    fdc3 =\n        max(λ3, 0.0) * (\n            (-uq42 * d1 + nx * d2 + ny * d3) / 2.0 +\n            rc1 * (ecAv * d1 - uAv * d2 - vAv * d3 + d4) / 2.0\n        )\n    fdc4 =\n        max(λ4, 0.0) * (\n            (uq42 * d1 - nx * d2 - ny * d3) / 2.0 +\n            rc1 * (ecAv * d1 - uAv * d2 - vAv * d3 + d4) / 2.0\n        )\n\n    duv1 = fdc1 + (fdc3 + fdc4) / cAv\n    duv2 = uAv * fdc1 + ny * fdc2 + (uAv / cAv + nx) * fdc3 + (uAv / cAv - nx) * fdc4\n    duv3 = vAv * fdc1 - nx * fdc2 + (vAv / cAv + ny) * fdc3 + (vAv / cAv - ny) * fdc4\n    duv4 =\n        ecAv * fdc1 +\n        (ny * uAv - nx * vAv) * fdc2 +\n        (uq41 + uq42) * fdc3 +\n        (uq41 - uq42) * fdc4\n\n    flux_ρ  += duv1\n    flux_ρu += duv2\n    flux_ρv += duv3\n    flux_ρE += duv4\n\n    return (δλ_ρ1 ⋅ flux_ρ + δλ_ρu1 ⋅ SA[flux_ρu, flux_ρv] + δλ_ρE1 ⋅ flux_ρE)\nend\n\n\"\"\"\n    flux_Γ_farfield(q, v, n)\n\nCompute `Roe` flux on boundary face by imposing\n`stateBcFarfield.u_in` on `side_p`\n\"\"\"\nflux_Γ_farfield(q, v, n) = flux_roe ∘ (side⁻(q), stateBcFarfield.u_inf, side⁻(v), side⁻(n))\n\n\"\"\"\n    flux_Γ_wall(q, v, n)\n\"\"\"\nflux_Γ_wall(q, v, n) = _flux_Γ_wall ∘ (side⁻(q), side⁻(v), side⁻(n))\n\nfunction _flux_Γ_wall(q⁻, v⁻, n)\n    γ = stateInit.γ\n    ρ1, ρu1, ρE1 = q⁻\n    λ_ρ1, λ_ρu1, λ_ρE1 = v⁻\n\n    p1 = pressure(ρ1, ρu1, ρE1, γ)\n\n    flux_ρ  = zero(ρ1)\n    flux_ρu = p1 * n\n    flux_ρE = zero(ρE1)\n\n    return (λ_ρ1 ⋅ flux_ρ + λ_ρu1 ⋅ flux_ρu + λ_ρE1 ⋅ flux_ρE)\nend\n\nfunction sparse2vtk(\n    a::AbstractSparseMatrix,\n    name::String = string(@__DIR__, \"../../../myout/sparse\"),\n)\n    BcubeVTK.vtk_write_array(name, Array(a), \"my_property_name\")\nend\n\nmutable struct VtkHandler\n    basename::String\n    basename_residual::String\n    ite::Int\n    VtkHandler(basename) = new(basename, basename * \"_residual\", 0)\nend\n\n\"\"\"\n    Write solution (at cell centers) to vtk\n    Wrapper for `write_vtk`\n\"\"\"\nfunction append_vtk(vtk, mesh, vars, t, params; res = nothing)\n    ρ, ρu, ρE = vars\n\n    # Mean cell values\n    # name2val_mean = (;zip(get_name.(vars), mean_values.(vars, degquad))...)\n    # p_mean = pressure.(name2val_mean[:ρ], name2val_mean[:ρu], name2val_mean[:ρE], params.stateInit.γ)\n\n    vtk_degree = maximum(x -> get_degree(Bcube.get_function_space(get_fespace(x))), vars)\n    vtk_degree = max(1, mesh_degree, vtk_degree)\n\n    Cp = pressure_coefficient ∘ (ρ, ρu, ρE)\n    Ma = mach ∘ (ρ, ρu, ρE)\n    dict_vars_dg = Dict(\n        \"rho\" => ρ,\n        \"rhou\" => ρu,\n        \"rhoE\" => ρE,\n        \"Cp\" => Cp,\n        \"Mach\" => Ma,\n        \"rho_mean\" => cell_mean(ρ, params.dΩ),\n        \"rhou_mean\" => cell_mean(ρu, params.dΩ),\n        \"rhoE_mean\" => cell_mean(ρE, params.dΩ),\n        \"lim_rho\" => params.limρ,\n        \"lim_all\" => params.limAll,\n    )\n    write_file(\n        vtk.basename * \"_DG.pvd\",\n        mesh,\n        dict_vars_dg,\n        vtk.ite,\n        t;\n        discontinuous = true,\n        mesh_degree = vtk_degree,\n        collection_append = vtk.ite > 0,\n    )\n\n    _ρ_wall = var_on_bnd_nodes_discontinuous(ρ, params.Γ_wall, vtk_degree)\n    _ρu_wall = var_on_bnd_nodes_discontinuous(ρu, params.Γ_wall, vtk_degree)\n    _ρE_wall = var_on_bnd_nodes_discontinuous(ρE, params.Γ_wall, vtk_degree)\n\n    Cp_wall = pressure_coefficient.(_ρ_wall, _ρu_wall, _ρE_wall)\n    Ma_wall = pressure_coefficient.(_ρ_wall, _ρu_wall, _ρE_wall)\n\n    dict_vars_wall = Dict(\n        \"rho\" => (_ρ_wall, VTKPointData()),\n        \"rhou\" => (_ρu_wall, VTKPointData()),\n        \"rhoE\" => (_ρE_wall, VTKPointData()),\n        \"Cp\" => (Cp_wall, VTKPointData()),\n        \"Mach\" => (Ma_wall, VTKPointData()),\n    )\n    BcubeVTK.write_vtk_bnd_discontinuous(\n        vtk.basename * \"_bnd_DG\",\n        1,\n        0.0,\n        params.Γ_wall,\n        dict_vars_wall,\n        vtk_degree;\n        append = false,\n    )\n\n    #residual:\n    if !isa(res, Nothing)\n        vtkfile = vtk_grid(vtk.basename_residual, Float64.(res.iter), [0.0, 1.0])\n        for (k, valₖ) in enumerate(res.val)\n            vtkfile[\"res_\" * string(k), VTKPointData()] = [valₖ valₖ]\n        end\n        vtk_save(vtkfile)\n    end\n\n    # Update counter\n    vtk.ite += 1\n\n    return nothing\nend\n\nfunction init!(q, dΩ, initstate)\n    AoA  = initstate.AoA\n    Minf = initstate.M_inf\n    Pinf = initstate.P_inf\n    Tinf = initstate.T_inf\n    r    = initstate.r_gas\n    γ    = initstate.γ\n\n    ρinf = Pinf / r / Tinf\n    ainf = √(γ * r * Tinf)\n    Vinf = Minf * ainf\n    ρVxinf = ρinf * Vinf * cos(AoA)\n    ρVyinf = ρinf * Vinf * sin(AoA)\n    ρEinf = Pinf / (γ - 1) + 0.5 * ρinf * Vinf^2\n\n    ρ0  = PhysicalFunction(x -> ρinf)\n    ρu0 = PhysicalFunction(x -> SA[ρVxinf, ρVyinf])\n    ρE0 = PhysicalFunction(x -> ρEinf)\n    projection_l2!(q, (ρ0, ρu0, ρE0), dΩ)\n    return nothing\nend\n\nfunction main(stateInit, stateBcFarfield, degree)\n    @show degree, degquad\n\n    mesh = read_mesh(dir * \"../../../input/mesh/naca0012_o\" * string(mesh_degree) * \".msh\")\n    scale!(mesh, 1.0 / 0.5334)\n\n    dimcar = compute_dimcar(mesh)\n\n    DMPrelax = DMPcurv₀ .* dimcar .^ 2\n\n    # Then we create a `NamedTuple` to hold the simulation parameters.\n    params = (\n        degquad = degquad,\n        stateInit = stateInit,\n        stateBcFarfield = stateBcFarfield,\n        DMPrelax = DMPrelax,\n    )\n\n    # Define measures for cell and interior face integrations\n    dΩ = Measure(CellDomain(mesh), degquad)\n    dΓ = Measure(InteriorFaceDomain(mesh), degquad)\n\n    # Declare boundary conditions and\n    # create associated domains and measures\n    Γ_wall      = BoundaryFaceDomain(mesh, (\"NACA\",))\n    Γ_farfield  = BoundaryFaceDomain(mesh, (\"FARFIELD\",))\n    dΓ_wall     = Measure(Γ_wall, degquad)\n    dΓ_farfield = Measure(Γ_farfield, degquad)\n\n    params = (\n        params...,\n        Γ_wall = Γ_wall,\n        dΓ = dΓ,\n        dΩ = dΩ,\n        dΓ_wall = dΓ_wall,\n        dΓ_farfield = dΓ_farfield,\n    )\n\n    qLowOrder = nothing\n\n    for deg in 0:degree\n        params = (params..., degree = deg)\n\n        fs = FunctionSpace(fspace, deg)\n        Q_sca = TrialFESpace(fs, mesh, :discontinuous; size = 1) # DG, scalar\n        Q_vec = TrialFESpace(fs, mesh, :discontinuous; size = 2) # DG, vectoriel\n        V_sca = TestFESpace(Q_sca)\n        V_vec = TestFESpace(Q_vec)\n        Q = MultiFESpace(Q_sca, Q_vec, Q_sca)\n        V = MultiFESpace(V_sca, V_vec, V_sca)\n\n        q = FEFunction(Q)\n\n        # select an initial configurations:\n        if deg == 0\n            init!(q, mesh, stateInit)\n        else\n            println(\"Start projection\")\n            projection_l2!(q, qLowOrder, dΩ)\n            println(\"End projection\")\n        end\n\n        # create CellData to store limiter values\n        limρ = Bcube.MeshCellData(ones(ncells(mesh)))\n        limAll = Bcube.MeshCellData(ones(ncells(mesh)))\n        params = (params..., limρ = limρ, limAll = limAll)\n\n        # Init vtk handler\n        mkpath(outputpath)\n        vtk = VtkHandler(\n            outputpath * \"euler_naca_mdeg\" * string(mesh_degree) * \"_deg\" * string(deg),\n        )\n\n        # Init time\n        time = 0.0\n\n        # Save initial solution\n        append_vtk(vtk, mesh, q, time, params)\n\n        # Build the cache and store everything you want to compute only once (such as the mass matrice inverse...)\n\n        cache = ()\n        # Allocate buffer for compute_residual\n        b_vol = zeros(Bcube.get_ndofs(Q))\n        b_fac = zeros(Bcube.get_ndofs(Q))\n        cache = (cache..., b_vol = b_vol, b_fac = b_fac)\n\n        cache = (\n            cache...,\n            cacheCellMean = Bcube.build_cell_mean_cache(q, dΩ),\n            mass = factorize(Bcube.build_mass_matrix(Q, V, dΩ)),\n            mass_sca = factorize(Bcube.build_mass_matrix(Q_sca, V_sca, dΩ)),\n            mass_vec = factorize(Bcube.build_mass_matrix(Q_vec, V_vec, dΩ)),\n        )\n\n        time, q = steady_solve!(Q, V, q, mesh, params, cache, vtk, deg)\n        append_vtk(vtk, mesh, q, time, params)\n        println(\"end steady_solve for deg=\", deg, \" !\")\n\n        deg < degree && (qLowOrder = deepcopy(q))\n    end\n    return nothing\nend\n\nfunction steady_solve!(Q, V, q, mesh, params, cache, vtk, deg)\n    counter = [0]\n    q0 = deepcopy(get_dof_values(q))\n    ode_params =\n        (Q = Q, V = V, params = params, cache = cache, counter = counter, vtk = vtk)\n\n    rhs!(dq, q, p, t) = dq .= compute_residual(q, p.Q, p.V, p.params)\n\n    # compute sparsity pattern and coloring\n    println(\"computing jacobian cache...\")\n    if withbench\n        _rhs!(dq, q) = rhs!(dq, q, ode_params, 0.0)\n        @btime $_rhs!(similar($q0), $q0)\n        q_bench = FEFunction(Q, q0)\n        @btime $apply_limitation!($q_bench, $ode_params)\n        @show length(q0)\n    end\n\n    #sparsity_pattern = Symbolics.jacobian_sparsity(_rhs!, similar(Q0), Q0)\n    #tjac = @elapsed Symbolics.jacobian_sparsity(_rhs!, similar(Q0), Q0)\n    #@show tjac\n    sparsity_pattern = Bcube.build_jacobian_sparsity_pattern(Q, mesh)\n    println(\"sparsity pattern computed !\")\n    display(sparsity_pattern)\n    colors = matrix_colors(sparsity_pattern)\n    println(\"coloring done!\")\n    @show maximum(colors)\n\n    ode = ODEFunction(\n        rhs!;\n        mass_matrix = Bcube.build_mass_matrix(Q, V, params.dΩ),\n        jac_prototype = sparsity_pattern,\n        colorvec = colors,\n    )\n\n    Tfinal      = Inf\n    problem     = ODEProblem(ode, q0, (0.0, Tfinal), ode_params)\n    timestepper = ImplicitEuler(; nlsolve = NLNewton(; max_iter = 20))\n\n    cb_cache  = DiscreteCallback(always_true, update_cache!; save_positions = (false, false))\n    cb_vtk    = DiscreteCallback(always_true, output_vtk; save_positions = (false, false))\n    cb_steady = TerminateSteadyState(1e-6, 1e-6, condition_steadystate)\n\n    error = 1e-1\n\n    sol = solve(\n        problem,\n        timestepper;\n        initializealg = NoInit(),\n        adaptive = true,\n        abstol = error,\n        reltol = error,\n        progress = false,\n        progress_steps = 1000,\n        save_everystep = false,\n        save_start = false,\n        save_end = false,\n        isoutofdomain = isoutofdomain,\n        callback = CallbackSet(cb_cache, cb_vtk, cb_steady),\n    )\n\n    set_dof_values!(q, sol.u[end])\n    return sol.t[end], q\nend\n\nalways_true(args...) = true\n\nfunction isoutofdomain(dof, p, t)\n    any(isnan, dof) && return true\n\n    q = FEFunction(p.Q, dof)\n    q_mean = map(get_values, cell_mean(q, p.cache.cacheCellMean))\n    p_mean = pressure.(q_mean..., stateInit.γ)\n\n    negative_ρ = any(x -> x < 0, q_mean[1])\n    negative_p = any(x -> x < 0, p_mean)\n    isout = negative_ρ || negative_p\n    isout && @show negative_ρ, negative_p\n    return isout\nend\n\nfunction update_cache!(integrator)\n    Q = integrator.p.Q\n    Q1, = Q\n    deg = get_degree(Bcube.get_function_space(Q1))\n    println(\n        \"deg=\",\n        deg,\n        \" update_cache! : iter=\",\n        integrator.p.counter[1],\n        \" dt=\",\n        integrator.dt,\n    )\n\n    q = FEFunction(integrator.p.Q, integrator.u)\n    limiter_projection && apply_limitation!(q, integrator.p)\n    return nothing\nend\n\nfunction output_vtk(integrator)\n    u_modified!(integrator, false)\n    mesh = get_mesh(get_domain(integrator.p.params.dΩ))\n    q = FEFunction(integrator.p.Q, integrator.u)\n    counter = integrator.p.counter\n    counter .+= 1\n    if (counter[1] % nout == 0)\n        println(\"output_vtk \", counter[1])\n        append_vtk(integrator.p.vtk, mesh, q, integrator.t, integrator.p.params)\n    end\n    return nothing\nend\n\nfunction condition_steadystate(integrator, abstol, reltol, min_t)\n    u_modified!(integrator, false)\n    if DiffEqBase.isinplace(integrator.sol.prob)\n        testval = first(get_tmp_cache(integrator))\n        @. testval = (integrator.u - integrator.uprev) / (integrator.t - integrator.tprev)\n    else\n        testval = (integrator.u - integrator.uprev) / (integrator.t - integrator.tprev)\n    end\n\n    if typeof(integrator.u) <: Array\n        any(\n            abs(d) > abstol && abs(d) > reltol * abs(u) for (d, abstol, reltol, u) in\n            zip(testval, Iterators.cycle(abstol), Iterators.cycle(reltol), integrator.u)\n        ) && (return false)\n    else\n        any((abs.(testval) .> abstol) .& (abs.(testval) .> reltol .* abs.(integrator.u))) &&\n            (return false)\n    end\n\n    if min_t === nothing\n        return true\n    else\n        return integrator.t >= min_t\n    end\nend\n\n\"\"\"\nCompute the characteristic dimension of each cell of `mesh`:\ndimcar = (cell volume) / (cell surface)\n\n# TODO :\nto be moved to Bcube\n\"\"\"\nfunction compute_dimcar(mesh)\n    fs = FunctionSpace(:Lagrange, 0)\n    V = TestFESpace(fs, mesh; size = 1, isContinuous = false)\n\n    # Define measures for cell and interior face integrations\n    dΩ = Measure(CellDomain(mesh), degquad)\n    dΓ = Measure(InteriorFaceDomain(mesh), degquad)\n    dΓ_bc = Measure(BoundaryFaceDomain(mesh), degquad)\n\n    f1 = PhysicalFunction(x -> 1.0)\n    l(v) = ∫(f1 ⋅ v)dΩ\n    l_face(v, dω) = ∫(side⁻(f1) ⋅ side⁻(v) + side⁺(f1) ⋅ side⁺(v))dω\n\n    vol = assemble_linear(l, V)\n    surf = assemble_linear(Base.Fix2(l_face, dΓ), V)\n    surf += assemble_linear(Base.Fix2(l_face, dΓ_bc), V)\n    return vol ./ surf\nend\n\n\"\"\"\nReferences:\n* Xiangxiong Zhang, Chi-Wang Shu, On positivity-preserving high order discontinuous\n  Galerkin schemes for compressible Euler equations on rectangular meshes,\n  Journal of Computational Physics, Volume 229, Issue 23, 2010.\n  https://doi.org/10.1016/j.jcp.2010.08.016\n* Zhang, X., Xia, Y. & Shu, CW. Maximum-Principle-Satisfying and Positivity-Preserving\n  High Order Discontinuous Galerkin Schemes for Conservation Laws on Triangular Meshes.\n  J Sci Comput 50, 29–62 (2012). https://doi.org/10.1007/s10915-011-9472-8\n\"\"\"\nfunction apply_limitation!(q::Bcube.AbstractFEFunction, ode_params)\n    params = ode_params.params\n    cache = ode_params.cache\n    mesh = get_mesh(get_domain(params.dΩ))\n    ρ, ρu, ρE = q\n\n    ρ_mean, ρu_mean, ρE_mean = cell_mean(q, cache.cacheCellMean)\n\n    _limρ, ρ_proj = linear_scaling_limiter(\n        ρ,\n        params.dΩ;\n        bounds = (ρmin₀, ρmax₀),\n        DMPrelax = params.DMPrelax,\n        mass = cache.mass_sca,\n    )\n\n    op_t = limiter_param_p ∘ (ρ_proj, ρu, ρE, ρ_mean, ρu_mean, ρE_mean)\n    t = Bcube._minmax_cells(op_t, mesh, Val(params.degquad))\n    tmin = Bcube.MeshCellData(getindex.(t, 1))\n\n    if eltype(_limρ) == eltype(params.limρ) # skip Dual number case\n        set_values!(params.limρ, get_values(_limρ))\n        set_values!(params.limAll, get_values(tmin))\n    end\n\n    limited_var(u, ū, lim_u) = ū + lim_u * (u - ū)\n    projection_l2!(ρ, limited_var(ρ_proj, ρ_mean, tmin), params.dΩ; mass = cache.mass_sca)\n    projection_l2!(ρu, limited_var(ρu, ρu_mean, tmin), params.dΩ; mass = cache.mass_vec)\n    projection_l2!(ρE, limited_var(ρE, ρE_mean, tmin), params.dΩ; mass = cache.mass_sca)\n    return nothing\nend\n\nfunction limiter_param_p(ρ̂, ρu, ρE, ρ_mean, ρu_mean, ρE_mean)\n    γ = stateInit.γ\n    p = pressure(ρ̂, ρu, ρE, γ)\n\n    if p ≥ pmin₀\n        t = 1.0\n    else\n        @show p, ρ̂, ρu, ρE\n        @show ρ_mean, ρu_mean, ρE_mean\n        @show pressure(ρ_mean, ρu_mean, ρE_mean, γ)\n        if pressure(ρ_mean, ρu_mean, ρE_mean, γ) > pmin₀\n            fₜ =\n                t ->\n                    pressure(\n                        t * ρ̂ + (1 - t) * ρ_mean,\n                        t * ρu + (1 - t) * ρu_mean,\n                        t * ρE + (1 - t) * ρE_mean,\n                        γ,\n                    ) - pmin₀\n            bounds = (0.0, 1.0)\n            t = find_zero(fₜ, bounds, Bisection())\n        else\n            t = NaN\n            println(\"t = NaN\")\n        end\n    end\n\n    return t\nend\n\nfunction pressure(ρ::Number, ρu::AbstractVector, ρE::Number, γ)\n    vel = ρu ./ ρ\n    ρuu = ρu * transpose(vel)\n    p = (γ - 1) * (ρE - tr(ρuu) / 2)\n    return p\nend\n\ncompute_Pᵢ(P, γ, M) = P * (1 + 0.5 * (γ - 1) * M^2)^(γ / (γ - 1))\ncompute_Tᵢ(T, γ, M) = T * (1 + 0.5 * (γ - 1) * M^2)\n\nfunction bc_state_farfield(AoA, M, P, T, r, γ)\n    a = √(γ * r * T)\n    vn = M * a\n    ρ = P / r / T\n    ρu = SA[ρ * vn * cos(AoA), ρ * vn * sin(AoA)]\n    ρE = P / (γ - 1) + 0.5 * ρ * vn^2\n    return (ρ, ρu, ρE)\nend\n\nfunction pressure_coefficient(ρ, ρu, ρE)\n    (pressure(ρ, ρu, ρE, stateInit.γ) - stateInit.P_inf) /\n    (stateBcFarfield.Pᵢ_inf - stateInit.P_inf)\nend\nfunction mach(ρ, ρu, ρE)\n    norm(ρu ./ ρ) / √(stateInit.γ * max(0.0, pressure(ρ, ρu, ρE, stateInit.γ) / ρ))\nend\n\nconst degreemax = 2 # Function-space degree\nconst mesh_degree = 2\nconst fspace = :Lagrange\nconst limiter_projection = true\nconst ρmin₀ = 1.0e-8\nconst ρmax₀ = 1.0e+10\nconst pmin₀ = 1.0e-8\nconst pmax₀ = 1.0e+10\nconst DMPcurv₀ = 10.0e3\nconst withbench = false\n\nconst stateInit = (\n    AoA = deg2rad(1.25),\n    M_inf = 0.8,\n    P_inf = 101325.0,\n    T_inf = 275.0,\n    r_gas = 287.0,\n    γ = 1.4,\n)\nconst nite_max = 300 #300000 # Number of time iteration(s)\nconst nout = 1 # number of step between two vtk outputs\nconst mass_matrix_in_solve = true\nconst degquad = 6\nconst outputpath = joinpath(@__DIR__, \"../../../myout/euler_naca_steady/\")\n\nconst stateBcFarfield = (\n    AoA = stateInit.AoA,\n    M_inf = stateInit.M_inf,\n    Pᵢ_inf = compute_Pᵢ(stateInit.P_inf, stateInit.γ, stateInit.M_inf),\n    Tᵢ_inf = compute_Tᵢ(stateInit.T_inf, stateInit.γ, stateInit.M_inf),\n    u_inf = bc_state_farfield(\n        stateInit.AoA,\n        stateInit.M_inf,\n        stateInit.P_inf,\n        stateInit.T_inf,\n        stateInit.r_gas,\n        stateInit.γ,\n    ),\n    r_gas = stateInit.r_gas,\n    γ = stateInit.γ,\n)\n\nmain(stateInit, stateBcFarfield, degreemax)\n\nend #hide","category":"page"},{"location":"example/transport_hypersurface/#Transport-equation-on-hypersurfaces","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":"","category":"section"},{"location":"example/transport_hypersurface/","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":"In this file, a linear transport equation is solved on several hypersurfaces. The scalar transport equation is","category":"page"},{"location":"example/transport_hypersurface/","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":"  partial_t u + c cdot nabla_Gamma u = 0","category":"page"},{"location":"example/transport_hypersurface/","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":"where c is the (tangential) transport velocity (always divergent-free in these examples); and nabla_Gamma is the tangential gradient. The vector transport equation is","category":"page"},{"location":"example/transport_hypersurface/","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":" partial_t u + nabla_Gamma (c otimes u) = 0","category":"page"},{"location":"example/transport_hypersurface/","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":"Here is an example of the transport of a scalar bump on a torus meshed with P2 triangles:","category":"page"},{"location":"example/transport_hypersurface/","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":"(Image: )","category":"page"},{"location":"example/transport_hypersurface/","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":"using Plots\nusing Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing StaticArrays\nusing LinearAlgebra\nusing Printf\nusing DelimitedFiles\nusing Random\nusing ProgressMeter\nusing Profile\nusing BenchmarkTools\n\nconst out_dir = joinpath(@__DIR__, \"../../../myout/transport_hypersurface\")\nrm(out_dir; force = true, recursive = true)\nmkpath(out_dir)\n\n\"\"\" Norm alias for AbstractLazy \"\"\"\nmynorm(a) = sqrt(a ⋅ a)\n\n\"\"\" Tangential divergence operator \"\"\"\ndivₛ(a) = tr(∇ₛ(a))\n\nmutable struct VtkHandler\n    basename::Any\n    ite::Any\n    mesh::Any\n    dΩ::Any\n    U::Any\n    θ::Any\n    θ_centers::Any\n    c::Any\n    c_centers::Any\n    ν::Any\n    ν_centers::Any\n    function VtkHandler(basename, dΩ, U, c)\n        @info \"Writing to $basename.vtu\"\n\n        mesh = get_mesh(get_domain(dΩ))\n        θ = PhysicalFunction(x -> atan(x[2], x[1]))\n        θ_centers = MeshCellData(var_on_centers(θ, mesh))\n\n        ν = get_cell_normals(dΩ)\n        ν_centers = var_on_centers(ν, mesh)\n        _ν_centers = MeshCellData([SA[ν_centers[i, :]...] for i in 1:ncells(mesh)])\n\n        c_centers = var_on_centers(c, mesh)\n        _c_centers = MeshCellData([SA[c_centers[i, :]...] for i in 1:ncells(mesh)])\n\n        new(basename, 0, mesh, dΩ, U, θ, θ_centers, c, _c_centers, ν, _ν_centers)\n    end\nend\n\nfunction plot_solution(i, t, u, mesh, xcenters, ycenters, xnodes, ynodes)\n    # Build animation\n    uplot = var_on_centers(u, mesh)\n    lmax = 1.5\n\n    plt = plot(\n        [xnodes..., xnodes[1]],\n        [ynodes..., ynodes[1]];\n        aspect_ratio = :equal,\n        primary = false,\n        xlim = (-lmax, lmax),\n        ylim = (-lmax, lmax),\n    )\n    annotate!(0, 0.25, \"i  = $i\")\n    annotate!(0, 0, @sprintf \"t = %.2e\" t)\n\n    if ndims(uplot) == 1\n        scatter!(xcenters, ycenters; marker_z = uplot, label = \"u\", clims = (-1, 1))\n        annotate!(0, -0.25, @sprintf \"|u|_max = %.2e\" maximum(abs.(uplot)))\n    elseif ndims(uplot) == 2\n        L = maximum(x -> norm(x), eachrow(uplot))\n        scale = 0.75\n        uplot .*= scale\n        quiver!(\n            xcenters,\n            ycenters;\n            quiver = (uplot[:, 1], uplot[:, 2]),\n            label = \"u\",\n            xlabel = \"x\",\n            ylabel = \"y\",\n        )\n        annotate!(0, -0.25, @sprintf \"|u|_max = %.2e\" L)\n    end\n\n    return plt\nend\n\n\"\"\"\n    rotMat(θx, θy, θz)\n\nBuild the 3D rotation matrix from the angles given for each axis.\n\"\"\"\nfunction rotMat(θx, θy, θz)\n    Rx = @SMatrix[\n        1.0 0.0 0.0\n        0.0 cos(θx) sin(θx)\n        0.0 (-sin(θx)) cos(θx)\n    ]\n    Ry = @SMatrix[\n        cos(θy) 0.0 (-sin(θy))\n        0.0 1.0 0.0\n        sin(θy) 0.0 cos(θy)\n    ]\n    Rz = @SMatrix[\n        cos(θz) sin(θz) 0.0\n        -sin(θz) cos(θz) 0.0\n        0.0 0.0 1.0\n    ]\n    return Rx * Ry * Rz\nend\n\n\"\"\"\nLinear transport of a scalar quantity on a circle\n\nnrot = number of \"rotations\" to run (in time)\nvolumic_bilinear = true means the volumic term is assembled once with a bilinear assembly while false means\n    a linear assembly (and hence the limiter is applied)\n\"\"\"\nfunction scalar_circle(;\n    degree,\n    CFL,\n    nθ,\n    nrot = 2,\n    nout = 100,\n    nitemax = Int(1e9),\n    volumic_bilinear = false,\n    isLimiterActive = true,\n)\n    function append_vtk(vtk, u::Bcube.AbstractFEFunction, lim_u, u_mean, t)\n        # Build animation\n        values_centers = var_on_centers(u, mesh)\n\n        # Write\n        write_file(\n            vtk.basename * \".pvd\",\n            vtk.mesh,\n            Dict(\n                \"u_centers\" => MeshCellData(values_centers),\n                \"u_vertices\" => u,\n                \"lim_u\" => lim_u,\n                \"u_mean\" => u_mean,\n                \"θ_centers\" => vtk.θ_centers,\n                \"θ_vertices\" => vtk.θ,\n            ),\n            vtk.ite,\n            t,\n            ;\n            collection_append = vtk.ite > 0,\n        )\n\n        # Update counter\n        vtk.ite += 1\n    end\n\n    # Settings\n    radius = 1.0\n    C = 1.0 ## velocity norm\n    tmax = nrot * 2π / C\n\n    # Mesh\n    qOrder = 2 * degree + 1 ## we shall use Gauss-Lobatto for degree > 0, but in 1D this is ok\n    mesh = circle_mesh(nθ; radius = radius, order = 1)\n    dΩ = Measure(CellDomain(mesh), qOrder)\n    Γ = InteriorFaceDomain(mesh)\n    dΓ = Measure(Γ, qOrder)\n    nΓ = get_face_normals(Γ)\n\n    # FESpace\n    fs = FunctionSpace(:Lagrange, degree)\n    U = TrialFESpace(fs, mesh, :discontinuous)\n    V = TestFESpace(U)\n\n    # Transport velocity\n    _c = PhysicalFunction(x -> C * SA[-x[2], x[1]] / radius)\n    P = Bcube.tangential_projector()\n    c = (x -> C * normalize(x)) ∘ (P * _c) ## useless in theory since velocity is already tangent\n\n    # Find quadrature weight (mesh is composed of a unique \"shape\" so first element is enough)\n    quad = Bcube.get_quadrature(dΩ)\n    s = Bcube.shape(Bcube.cells(mesh)[1])\n    qrule = Bcube.QuadratureRule(s, quad)\n    ω_quad = degree > 0 ? Bcube.get_weights(qrule)[1] : 1.0\n\n    # Time step and else\n    dl = 2π * radius / nθ ## analytic length\n    dl = 2 * radius * sin(2π / nθ / 2) ## discretized length\n    Δt = CFL * dl * ω_quad / C / (2 * degree + 1)\n    t = 0.0\n    nite = min(floor(Int, tmax / Δt), nitemax)\n    @show nite\n    _nout = min(nite, nout)\n\n    @show dl\n    @show Δt\n\n    # Limitation\n    DMPrelax = 0.0 * dl\n\n    # Output\n    tail = isLimiterActive ? \"lim\" : \"nolim\"\n    filename = \"scalar-on-circle-d$(degree)-$(tail)\"\n    vtk = VtkHandler(joinpath(out_dir, filename), dΩ, U, c)\n    dofOverTime = zeros(nite + 1, 2) ## t, u\n    i_dof_out = 1\n\n    # FEFunction and \"boundary / source\" condition\n    u = FEFunction(U)\n    if false\n        u.dofValues[1] = 1.0\n    else\n        projection_l2!(u, PhysicalFunction(x -> cos(atan(x[2], x[1]))), mesh)\n    end\n\n    # Forms\n    m(u, v) = ∫(u ⋅ v)dΩ ## Mass matrix\n    a_Ω(u, v) = ∫(u * (c ⋅ ∇ₛ(v)))dΩ ## bilinear volumic convective term\n\n    function upwind(ui, uj, ci, nij)\n        cij = ci ⋅ nij\n        if cij > zero(cij)\n            fij = cij * ui\n        else\n            fij = cij * uj\n        end\n        fij\n    end\n\n    # Mass\n    M = assemble_bilinear(m, U, V)\n    invM = inv(Matrix(M)) ##WARNING : really expensive !!!\n    if volumic_bilinear\n        K = assemble_bilinear(a_Ω, U, V)\n        invMK = invM * K\n    end\n\n    # Anim\n    anim = Animation()\n    xnodes = [get_coords(node, 1) for node in get_nodes(mesh)]\n    ynodes = [get_coords(node, 2) for node in get_nodes(mesh)]\n    xcenters = [center[1] for center in Bcube.get_cell_centers(mesh)]\n    ycenters = [center[2] for center in Bcube.get_cell_centers(mesh)]\n\n    # Initial solution\n    lim_u, _u = linear_scaling_limiter(u, dΩ; DMPrelax, mass = M)\n    isLimiterActive && (u.dofValues .= _u.dofValues)\n\n    u_mean = cell_mean(u, dΩ)\n    t = 0.0\n    plt = plot_solution(0, t, u, mesh, xcenters, ycenters, xnodes, ynodes)\n    append_vtk(vtk, u, lim_u, u_mean, t)\n    frame(anim, plt)\n    dofOverTime[1, :] .= t, u.dofValues[i_dof_out]\n\n    b = Bcube.allocate_dofs(U)\n    for ite in 1:nite\n        b .= 0.0\n\n        # Apply limitation\n        if isLimiterActive\n            lim_u, _u = linear_scaling_limiter(u, dΩ; DMPrelax, mass = M)\n            set_dof_values!(u, get_dof_values(_u))\n        end\n\n        # Define linear forms\n        flux = upwind ∘ (side⁻(u), side⁺(u), side⁻(c), side⁻(nΓ))\n        l_Γ(v) = ∫(-flux * jump(v))dΓ\n        l_Ω(v) = ∫(u * (c ⋅ ∇ₛ(v)))dΩ ## linear Volumic convective term\n        l(v) = l_Ω(v) + l_Γ(v)\n\n        if volumic_bilinear\n            # Version bilinear volumic term\n            assemble_linear!(b, l_Γ, V)\n            u.dofValues .= (I + Δt .* invMK) * u.dofValues + Δt .* invM * b\n        else\n            # Version linear volumic term\n            assemble_linear!(b, l, V)\n            u.dofValues .+= Δt .* invM * b\n        end\n\n        t += Δt\n\n        # Output results\n        if ite % (nite ÷ _nout) == 0\n            u_mean = cell_mean(u, dΩ)\n            append_vtk(vtk, u, lim_u, u_mean, t)\n            plt = plot_solution(vtk.ite, t, u, mesh, xcenters, ycenters, xnodes, ynodes)\n            frame(anim, plt)\n        end\n        dofOverTime[ite + 1, :] .= t, u.dofValues[i_dof_out]\n    end\n\n    # Output final result and anim\n    path = joinpath(out_dir, filename * \".csv\")\n    @info \"Writing to $path\"\n    open(path, \"w\") do io\n        println(io, \"t,u\")\n        writedlm(io, dofOverTime, \",\")\n    end\n    println(\"Computation is done, building gif...\")\n    g = gif(anim, joinpath(out_dir, \"$filename.gif\"); fps = 4)\n    display(g)\nend\n\n\"\"\"\nLinear transport of a vector quantity on a circle\n\"\"\"\nfunction vector_circle(; degree, nite, CFL, nθ)\n    # Settings\n    radius = 1.0\n    C = 1.0 ## velocity norm\n\n    # Mesh\n    mesh = circle_mesh(nθ; radius = radius, order = 1)\n    dΩ = Measure(CellDomain(mesh), 2 * degree + 1)\n    Γ = InteriorFaceDomain(mesh)\n    dΓ = Measure(Γ, 2 * degree + 1)\n    nΓ = get_face_normals(Γ)\n\n    # Operators\n    P = Bcube.tangential_projector()\n    R = Bcube.CoplanarRotation()\n\n    # Transport velocity : it must be coplanar to each element, so we use the\n    # tangential projector operator and force the projected velocity to have\n    # the same norm as the \"analytical\" one\n    _c = PhysicalFunction(x -> C * SA[-x[2], x[1]] / radius)\n    c = (x -> C * normalize(x)) ∘ (P * _c) ## useless in theory since velocity is already tangent\n\n    # FESpace\n    fs = FunctionSpace(:Lagrange, degree)\n    U = TrialFESpace(fs, mesh, :discontinuous; size = 2)\n    V = TestFESpace(U)\n\n    # FEFunction and \"boundary / source\" condition\n    u = FEFunction(U)\n\n    # Initial condition\n    _u0 = PhysicalFunction(x -> begin\n        θ = atan(x[2], x[1])\n        if 0 <= θ <= 2π / nθ\n            return radius * SA[-x[2], x[1]]\n        else\n            return SA[0, 0]\n        end\n    end)\n    projection_l2!(u, _u0, mesh)\n\n    # Forms\n    m(u, v) = ∫(u ⋅ v)dΩ ## Mass matrix\n    l_Ω(v) = ∫((u ⊗ c) ⊡ ∇ₛ(v))dΩ ## Volumic convective term\n\n    function upwind(ui, uj, Ri, Rj, vi, vj, ci, nij)\n        _uj = Ri * uj\n\n        cij = ci ⋅ nij\n        if cij > zero(cij)\n            fi = cij * ui\n        else\n            fi = cij * _uj\n        end\n\n        return fi ⋅ (vi - transpose(Rj) * vj)\n    end\n\n    function flux(v)\n        upwind ∘\n        (side⁻(u), side⁺(u), side⁻(R), side⁺(R), side⁻(v), side⁺(v), side⁻(c), side⁻(nΓ))\n    end\n    l_Γ(v) = ∫(-flux(v))dΓ\n\n    l(v) = l_Ω(v) + l_Γ(v)\n\n    # Time step\n    dl = 2π * radius / nθ ## analytic length\n    dl = 2 * radius * sin(2π / nθ / 2) ## discretized length\n    Δt = CFL * dl / C\n    @show dl\n    @show Δt\n\n    # Mass\n    M = assemble_bilinear(m, U, V)\n    invM = inv(Matrix(M)) ##WARNING : really expensive !!!\n    # display(invM)\n\n    # Anim\n    anim = Animation()\n    xnodes = [get_coords(node, 1) for node in get_nodes(mesh)]\n    ynodes = [get_coords(node, 2) for node in get_nodes(mesh)]\n    xcenters = [center[1] for center in Bcube.get_cell_centers(mesh)]\n    ycenters = [center[2] for center in Bcube.get_cell_centers(mesh)]\n\n    # Initial solution\n    plt = plot_solution(0, 0.0, u, mesh, xcenters, ycenters, xnodes, ynodes)\n    frame(anim, plt)\n\n    t = 0.0\n    b = Bcube.allocate_dofs(U)\n    for i in 1:nite\n        b .= 0.0\n        assemble_linear!(b, l, V)\n\n        u.dofValues .+= Δt .* invM * b\n\n        t += Δt\n\n        # Build animation\n        plt = plot_solution(i, t, u, mesh, xcenters, ycenters, xnodes, ynodes)\n        frame(anim, plt)\n    end\n\n    g = gif(anim, joinpath(out_dir, \"vector_on_circle_d$degree.gif\"); fps = 2)\n    display(g)\nend\n\n\"\"\"\nLinear transport of a scalar quantity on a cylinder\n\"\"\"\nfunction scalar_cylinder(;\n    degree,\n    CFL,\n    lz,\n    nz,\n    nθ,\n    tmax,\n    ϕ, ## velocity angle with respect to z axis\n    C, ## velocity norm\n    radius = 1,\n    nout = 100,\n    nitemax = Int(1e9),\n    isLimiterActive = true,\n    progressBar = true,\n    meshOrder = 1,\n    profile = false,\n)\n    function append_vtk(vtk, u::Bcube.AbstractFEFunction, lim_u, t)\n        vars = Dict(\n            \"u\" => u,\n            \"u_mean\" => cell_mean(u, vtk.dΩ),\n            \"lim_u\" => lim_u,\n            \"c\" => vtk.c,\n            \"cellnormal\" => vtk.ν,\n            \"u_warp\" => u * vtk.ν,\n        )\n        write_file(\n            vtk.basename * \"_lag.pvd\",\n            vtk.mesh,\n            vtk.U,\n            vars,\n            vtk.ite,\n            t;\n            collection_append = vtk.ite > 0,\n        )\n\n        # Update counter\n        vtk.ite += 1\n    end\n\n    # Mesh\n    mesh_path = joinpath(out_dir, \"mesh.msh\")\n    BcubeGmsh.gen_cylinder_shell_mesh(\n        mesh_path,\n        nθ,\n        nz;\n        lz,\n        radius,\n        lc = 1e-1,\n        recombine = true,\n        transfinite = true,\n        order = meshOrder,\n    )\n    mesh = read_mesh(mesh_path)\n    rng = Random.MersenneTwister(33)\n    θ = rand(rng, 3) .* 2π\n    println(\"θx, θy, θz = $(rad2deg.(θ))\")\n    Rmat = rotMat(θ...)\n    RmatInv = inv(Rmat)\n    transform!(mesh, x -> Rmat * x)\n\n    # Domains\n    # quad = Quadrature(QuadratureLobatto(), 2 * degree + 1)\n    quad = Quadrature(QuadratureLegendre(), 2 * degree + 1)\n    dΩ = Measure(CellDomain(mesh), quad)\n    Γ = InteriorFaceDomain(mesh)\n    dΓ = Measure(Γ, quad)\n    nΓ = get_face_normals(Γ)\n    Γ_bnd = BoundaryFaceDomain(mesh, (\"zmin\", \"zmax\"))\n    dΓ_bnd = Measure(Γ_bnd, quad)\n    nΓ_bnd = get_face_normals(Γ_bnd)\n\n    # FESpace\n    fs = FunctionSpace(:Lagrange, degree)\n    U = TrialFESpace(fs, mesh, :discontinuous)\n    V = TestFESpace(U)\n\n    # Transport velocity\n    Cz = C * cos(ϕ)\n    Cθ = C * sin(ϕ)\n    _c = PhysicalFunction(x -> begin\n        _x = RmatInv * x\n        Rmat * SA[-Cθ * _x[2] / radius, Cθ * _x[1] / radius, Cz]\n    end)\n    P = Bcube.tangential_projector()\n    c = (x -> C * normalize(x)) ∘ (P * _c)\n\n    # Find quadrature weight (mesh is composed of a unique \"shape\" so first element is enough)\n    quad = Bcube.get_quadrature(dΩ)\n    s = Bcube.shape(Bcube.cells(mesh)[1])\n    qrule = Bcube.QuadratureRule(s, quad)\n    ω_quad = degree > 0 ? Bcube.get_weights(qrule)[1] : 1.0\n\n    # Time step and else\n    dlθ = 2π * radius / nθ ## analytic length\n    dlθ = 2 * radius * sin(2π / nθ / 2) ## discretized length\n    dlz = lz / (nz - 1)\n    println(\"Timestep constrained by $(dlθ < dlz ? \"θ\" : \"z\") discretization\")\n    dl = min(dlθ, dlz)\n    Δt = CFL * dl * ω_quad / C / (2 * degree + 1)\n    t = 0.0\n    nite = min(floor(Int, tmax / Δt), nitemax)\n    _nout = min(nite, nout)\n\n    @show nite\n    @show dl\n    @show Δt\n    @show get_ndofs(U)\n\n    # Limitation\n    DMPrelax = 0.0 * dl\n\n    # Output\n    tail = isLimiterActive ? \"lim\" : \"nolim\"\n    filename = \"scalar-on-cylinder-d$(degree)-$(tail)\"\n    U_export =\n        TrialFESpace(FunctionSpace(:Lagrange, max(degree, meshOrder)), mesh, :discontinuous)\n    vtk = VtkHandler(joinpath(out_dir, filename), dΩ, U_export, c)\n\n    # FEFunction and initial solution (P3 Gaussian bump)\n    u = FEFunction(U)\n    _θ0 = 0\n    x0 = Rmat * SA[radius * cos(_θ0), radius * sin(_θ0), 0.2 * lz] ## bump center (in rotated frame)\n    _r = 1 ## bump radius\n    _umax = 1 ## bump amplitude\n    _a, _b = SA[\n        _r^3 _r^2\n        3*_r^2 2*_r\n    ] \\ SA[-_umax; 0]\n    f = PhysicalFunction(x -> begin\n        dx = norm(x - x0)\n        dx < _r ? _a * dx^3 + _b * dx^2 + _umax : 0.0\n    end)\n\n    projection_l2!(u, f, mesh)\n\n    # Forms\n    m(u, v) = ∫(u ⋅ v)dΩ ## Mass matrix\n\n    function upwind(ui, uj, ci, nij)\n        cij = ci ⋅ nij\n        if cij > zero(cij)\n            fij = cij * ui\n        else\n            fij = cij * uj\n        end\n        fij\n    end\n\n    # Mass\n    M = factorize(assemble_bilinear(m, U, V))\n\n    # Initial solution\n    lim_u, _u = linear_scaling_limiter(u, dΩ; DMPrelax, mass = M)\n    isLimiterActive && (u.dofValues .= _u.dofValues)\n\n    t = 0.0\n    append_vtk(vtk, u, lim_u, t)\n\n    b = Bcube.allocate_dofs(U)\n    du = similar(b)\n    progressBar && (progress = Progress(nitemax))\n    for ite in 1:nitemax\n        b .= 0.0\n\n        # Apply limitation\n        if isLimiterActive\n            lim_u, _u = linear_scaling_limiter(u, dΩ; DMPrelax, mass = M)\n            set_dof_values!(u, get_dof_values(_u))\n        end\n\n        # Define linear forms\n        flux = upwind ∘ (side⁻(u), side⁺(u), side⁻(c), side⁻(nΓ))\n        l_Γ(v) = ∫(-flux * jump(v))dΓ\n        flux_bnd = upwind ∘ (side⁻(u), side⁺(u), side⁻(c), side⁻(nΓ_bnd))\n        l_Γ_bnd(v) = ∫(-flux_bnd * jump(v))dΓ_bnd\n        l_Ω(v) = ∫(u * (c ⋅ ∇ₛ(v)))dΩ ## linear Volumic convective term\n        l(v) = l_Ω(v) + l_Γ(v) + l_Γ_bnd(v)\n\n        # Version linear volumic term\n        assemble_linear!(b, l, V)\n        du .= M \\ b\n        @. u.dofValues += Δt * du\n\n        t += Δt\n        progressBar && next!(progress)\n\n        # Output results\n        if ite % (nitemax ÷ _nout) == 0\n            append_vtk(vtk, u, lim_u, t)\n        end\n\n        if ite == nitemax && profile\n            println(\"ndofs total = \", Bcube.get_ndofs(U))\n            Profile.init(; n = 10^7) ## returns the current settings\n            Profile.clear()\n            Profile.clear_malloc_data()\n            @profile begin\n                for i in 1:1000\n                    assemble_linear!(b, l, V)\n                end\n            end\n            @btime assemble_linear!($b, $l, $V)\n        end\n    end\nend\n\n\"\"\"\nLinear transport of a vector quantity on a cylinder\n\"\"\"\nfunction vector_cylinder(;\n    degree,\n    CFL,\n    lz,\n    nz,\n    nθ,\n    tmax,\n    ϕ_vel, ## velocity angle with respect to z axis\n    C_vel, ## velocity norm\n    ϕ_u, ## transported vector angle with respect to z axis\n    C_u, ## transported vector norm\n    radius = 1,\n    nout = 100,\n    nitemax = Int(1e9),\n    isLimiterActive = true,\n    progressBar = true,\n)\n    function append_vtk(vtk, u::Bcube.AbstractFEFunction, lim_u, u_mean, t)\n        # Build animation\n        u_centers = var_on_centers(u, mesh)\n        _u_centers = MeshCellData([SA[u_centers[i, :]...] for i in 1:ncells(vtk.mesh)])\n\n        # Write\n        write_file(\n            vtk.basename * \".pvd\",\n            vtk.mesh,\n            Dict(\n                \"u_centers\" => _u_centers,\n                \"u_vertices\" => u,\n                \"lim_u\" => lim_u,\n                \"u_mean\" => u_mean,\n                \"θ_centers\" => vtk.θ_centers,\n                \"θ_vertices\" => vtk.θ,\n                \"c_centers\" => vtk.c_centers,\n                \"c_vertices\" => vtk.c,\n                \"ν_centers\" => vtk.ν_centers,\n                \"ν_vertices\" => vtk.ν,\n            ),\n            vtk.ite,\n            t,\n            ;\n            collection_append = vtk.ite > 0,\n        )\n\n        # Update counter\n        vtk.ite += 1\n    end\n\n    # Mesh\n    mesh_path = joinpath(out_dir, \"mesh.msh\")\n    BcubeGmsh.gen_cylinder_shell_mesh(\n        mesh_path,\n        nθ,\n        nz;\n        lz,\n        radius,\n        lc = 1e-1,\n        recombine = true,\n        transfinite = true,\n    )\n    mesh = read_mesh(mesh_path)\n    rng = Random.MersenneTwister(33)\n    θ = rand(rng, 3) .* 2π\n    println(\"θx, θy, θz = $(rad2deg.(θ))\")\n    Rmat = rotMat(θ...)\n    RmatInv = inv(Rmat)\n    transform!(mesh, x -> Rmat * x)\n\n    # Domains\n    # quad = Quadrature(QuadratureLobatto(), 2 * degree + 1)\n    quad = Quadrature(QuadratureLegendre(), 2 * degree + 1)\n    dΩ = Measure(CellDomain(mesh), quad)\n    Γ = InteriorFaceDomain(mesh)\n    dΓ = Measure(Γ, quad)\n    nΓ = get_face_normals(Γ)\n    Γ_bnd = BoundaryFaceDomain(mesh, (\"zmin\", \"zmax\"))\n    dΓ_bnd = Measure(Γ_bnd, quad)\n    nΓ_bnd = get_face_normals(Γ_bnd)\n\n    # FESpace\n    fs = FunctionSpace(:Lagrange, degree)\n    U = TrialFESpace(fs, mesh, :discontinuous; size = Bcube.spacedim(mesh))\n    V = TestFESpace(U)\n\n    # Operators\n    P = Bcube.tangential_projector()\n    R = Bcube.CoplanarRotation()\n\n    # Transport velocity\n    Cz = C_vel * cos(ϕ_vel)\n    Cθ = C_vel * sin(ϕ_vel)\n    _c = PhysicalFunction(x -> begin\n        _x = RmatInv * x\n        Rmat * SA[-Cθ * _x[2] / radius, Cθ * _x[1] / radius, Cz]\n    end)\n    c = (x -> C_vel * normalize(x)) ∘ (P * _c) ## useless in theory because velocity is already tangent\n\n    # Find quadrature weight (mesh is composed of a unique \"shape\" so first element is enough)\n    quad = Bcube.get_quadrature(dΩ)\n    s = Bcube.shape(Bcube.cells(mesh)[1])\n    qrule = Bcube.QuadratureRule(s, quad)\n    ω_quad = degree > 0 ? Bcube.get_weights(qrule)[1] : 1.0\n\n    # Time step and else\n    dlθ = 2π * radius / nθ ## analytic length\n    dlθ = 2 * radius * sin(2π / nθ / 2) ## discretized length\n    dlz = lz / (nz - 1)\n    println(\"Timestep constrained by $(dlθ < dlz ? \"θ\" : \"z\") discretization\")\n    dl = min(dlθ, dlz)\n    Δt = CFL * dl * ω_quad / C_vel / (2 * degree + 1)\n    t = 0.0\n    nite = min(floor(Int, tmax / Δt), nitemax)\n    _nout = min(nite, nout)\n\n    @show nite\n    @show dl\n    @show Δt\n    @show get_ndofs(U)\n\n    # Limitation\n    DMPrelax = 0.0 * dl\n\n    # Output\n    tail = isLimiterActive ? \"lim\" : \"nolim\"\n    filename = \"vector-on-cylinder-d$(degree)-$(tail)\"\n    vtk = VtkHandler(joinpath(out_dir, filename), dΩ, U, c)\n\n    # FEFunction and initial solution\n    u = FEFunction(U)\n    _θ0 = 0\n    x0 = Rmat * [radius * cos(_θ0), radius * sin(_θ0), 0.2 * lz] ## bump center (in rotated frame)\n    _r = 1 ## bump radius\n    _umax = C_u ## bump amplitude\n    _a, _b = [\n        _r^3 _r^2\n        3*_r^2 2*_r\n    ] \\ [-_umax; 0]\n    function norm_bump_p3(x)\n        dx = norm(x - x0)\n        y = dx < _r ? _a * dx^3 + _b * dx^2 + _umax : 0.0\n        return y * cos(ϕ_u), y * sin(ϕ_u)\n    end\n    _f = PhysicalFunction(\n        x -> begin\n            _Cz, _Cθ = norm_bump_p3(x)\n            _x = RmatInv * x\n            return Rmat * SA[-_Cθ * _x[2] / radius, _Cθ * _x[1] / radius, _Cz]\n        end,\n    )\n    f = C_u * (P * _f) / (mynorm(P * _f) + eps())\n    projection_l2!(u, f, mesh)\n\n    # Forms\n    m(u, v) = ∫(u ⋅ v)dΩ ## Mass matrix\n\n    function upwind(ui, uj, Ri, Rj, vi, vj, ci, nij)\n        _uj = Ri * uj\n\n        cij = ci ⋅ nij\n        if cij > zero(cij)\n            fi = cij * ui\n        else\n            fi = cij * _uj\n        end\n\n        return fi ⋅ (vi - transpose(Rj) * vj)\n    end\n\n    function flux(v, n)\n        upwind ∘\n        (side⁻(u), side⁺(u), side⁻(R), side⁺(R), side⁻(v), side⁺(v), side⁻(c), side⁻(n))\n    end\n\n    # Mass\n    M = assemble_bilinear(m, U, V)\n\n    # Initial solution\n    if isLimiterActive\n        lim_u, _u = linear_scaling_limiter(u, dΩ; DMPrelax, mass = M)\n        u.dofValues .= _u.dofValues\n    else\n        lim_u = MeshCellData(zero(get_dof_values(u))) ## dummy, just for the output\n    end\n\n    u_mean = cell_mean(u, dΩ)\n    t = 0.0\n    append_vtk(vtk, u, lim_u, u_mean, t)\n\n    b = Bcube.allocate_dofs(U)\n    du = similar(b)\n    progressBar && (progress = Progress(nitemax))\n    for ite in 1:nitemax\n        b .= 0.0\n\n        # Apply limitation\n        if isLimiterActive\n            lim_u, _u = linear_scaling_limiter(u, dΩ; DMPrelax, mass = M)\n            set_dof_values!(u, get_dof_values(_u))\n        end\n\n        # Define linear forms\n        l_Γ(v) = ∫(-flux(v, nΓ))dΓ\n        l_Γ_bnd(v) = ∫(-flux(v, nΓ_bnd))dΓ_bnd\n        l_Ω(v) = ∫((u ⊗ c) ⊡ ∇ₛ(v))dΩ ## linear Volumic convective term\n        l(v) = l_Ω(v) + l_Γ(v) + l_Γ_bnd(v)\n\n        # Version linear volumic term\n        assemble_linear!(b, l, V)\n        du .= M \\ b\n        @. u.dofValues += Δt * du\n\n        t += Δt\n        progressBar && next!(progress)\n\n        # Output results\n        if ite % (nitemax ÷ _nout) == 0\n            u_mean = cell_mean(u, dΩ)\n            append_vtk(vtk, u, lim_u, u_mean, t)\n        end\n    end\nend\n\n\"\"\"\nLinear transport of a scalar quantity on a torus\n\"\"\"\nfunction scalar_torus(;\n    degree,\n    CFL,\n    rint,\n    rext,\n    lc,\n    tmax,\n    ϕ, ## velocity angle with respect to z axis\n    C, ## velocity norm\n    nout = 100,\n    nitemax = Int(1e9),\n    isLimiterActive = true,\n    progressBar = true,\n    meshOrder = 1,\n)\n    function append_vtk(vtk, u::Bcube.AbstractFEFunction, lim_u, t)\n        vars = Dict(\n            \"u\" => u,\n            \"u_mean\" => cell_mean(u, vtk.dΩ),\n            \"lim_u\" => lim_u,\n            \"c\" => vtk.c,\n            \"cellnormal\" => vtk.ν,\n            \"u_warp\" => u * vtk.ν,\n        )\n        write_file(\n            vtk.basename * \"_lag.pvd\",\n            vtk.mesh,\n            vtk.U,\n            vars,\n            vtk.ite,\n            t;\n            collection_append = vtk.ite > 0,\n        )\n\n        # Update counter\n        vtk.ite += 1\n    end\n\n    # Mesh\n    mesh_path = joinpath(out_dir, \"mesh.msh\")\n    BcubeGmsh.gen_torus_shell_mesh(\n        mesh_path,\n        rint,\n        rext;\n        lc,\n        order = meshOrder,\n        verbose = false,\n    )\n    mesh = read_mesh(mesh_path)\n    rng = Random.MersenneTwister(33)\n    θ = zeros(3)\n    # θ = rand(rng, 3) .* 2π\n    println(\"θx, θy, θz = $(rad2deg.(θ))\")\n    Rmat = rotMat(θ...)\n    RmatInv = inv(Rmat)\n    transform!(mesh, x -> Rmat * x)\n\n    # Domains\n    # quad = Quadrature(QuadratureLobatto(), 2 * degree + 1)\n    quad = Quadrature(QuadratureLegendre(), 2 * degree + 1)\n    dΩ = Measure(CellDomain(mesh), quad)\n    Γ = InteriorFaceDomain(mesh)\n    dΓ = Measure(Γ, quad)\n    nΓ = get_face_normals(Γ)\n\n    # FESpace\n    fs = FunctionSpace(:Lagrange, degree)\n    U = TrialFESpace(fs, mesh, :discontinuous)\n    V = TestFESpace(U)\n\n    # Transport velocity\n    Cθ = C * cos(ϕ)\n    Cφ = C * sin(ϕ)\n    rc = (rint + rext) / 2\n    r = (rext - rint) / 2\n    ez = SA[0, 0, 1]\n    _c = PhysicalFunction(coords -> begin\n        _x = RmatInv * coords\n        x, y, z = _x\n\n        # In the (ex, ey) plane\n        r_xy = √(x * x + y * y)\n        cosθ = x / r_xy\n        sinθ = y / r_xy\n        er = SA[cosθ, sinθ, 0]\n        eθ = SA[-sinθ, cosθ, 0]\n\n        # In the (er, ez) plane\n        l = _x ⋅ er - rc\n        r_rz = √(z * z + l * l)\n        cosφ = l / r_rz\n        sinφ = z / r_rz\n        eφ = -sinφ * er + cosφ * ez\n\n        # direction vector\n        v = Cθ * eθ + Cφ * eφ\n\n        # Rotate back\n        Rmat * v\n    end)\n    ##P = Bcube.tangential_projector(mesh)\n    # c = (x -> C * normalize(x)) ∘ (P * _c) ## use this if `_c` is not necessarily tangent\n    c = _c ## `_c` is anatically tangent, so no need to project\n\n    # Find quadrature weight (mesh is composed of a unique \"shape\" so first element is enough)\n    quad = Bcube.get_quadrature(dΩ)\n    s = Bcube.shape(Bcube.cells(mesh)[1])\n    qrule = Bcube.QuadratureRule(s, quad)\n    ω_quad = degree > 0 ? Bcube.get_weights(qrule)[1] : 1.0\n\n    # Time step and else\n    dl = lc\n    Δt = CFL * dl * ω_quad / C / (2 * degree + 1)\n    t = 0.0\n    nite = min(floor(Int, tmax / Δt), nitemax)\n    _nout = min(nite, nout)\n\n    @show nite\n    @show dl\n    @show Δt\n    @show get_ndofs(U)\n\n    # Limitation\n    DMPrelax = 0.0 * dl\n\n    # Output\n    tail = isLimiterActive ? \"lim\" : \"nolim\"\n    filename = \"scalar-on-torus-d$(degree)-$(tail)\"\n    U_export =\n        TrialFESpace(FunctionSpace(:Lagrange, max(degree, meshOrder)), mesh, :discontinuous)\n    vtk = VtkHandler(joinpath(out_dir, filename), dΩ, U_export, c)\n\n    # FEFunction and initial solution (P3 Gaussian bump)\n    u = FEFunction(U)\n    _θ0 = π / 2\n    x0 = Rmat * SA[rc + r * cos(_θ0), 0.0, r * sin(_θ0)] ## bump center (in rotated frame)\n    _r = 0.5 ## bump radius\n    _umax = 1 ## bump amplitude\n    _a, _b = SA[\n        _r^3 _r^2\n        3*_r^2 2*_r\n    ] \\ SA[-_umax; 0]\n    f = PhysicalFunction(x -> begin\n        dx = norm(x - x0)\n        dx < _r ? _a * dx^3 + _b * dx^2 + _umax : 0.0\n    end)\n\n    projection_l2!(u, f, mesh)\n\n    # Forms\n    m(u, v) = ∫(u ⋅ v)dΩ ## Mass matrix\n\n    function upwind(ui, uj, ci, nij)\n        cij = ci ⋅ nij\n        if cij > zero(cij)\n            fij = cij * ui\n        else\n            fij = cij * uj\n        end\n        fij\n    end\n\n    # Mass\n    M = factorize(assemble_bilinear(m, U, V))\n\n    # Initial solution\n    lim_u, _u = linear_scaling_limiter(u, dΩ; DMPrelax, mass = M)\n    isLimiterActive && (u.dofValues .= _u.dofValues)\n\n    t = 0.0\n    append_vtk(vtk, u, lim_u, t)\n\n    b = Bcube.allocate_dofs(U)\n    du = similar(b)\n    progressBar && (progress = Progress(nite))\n    for ite in 1:nite\n        b .= 0.0\n\n        # Apply limitation\n        if isLimiterActive\n            lim_u, _u = linear_scaling_limiter(u, dΩ; DMPrelax, mass = M)\n            set_dof_values!(u, get_dof_values(_u))\n        end\n\n        # Define linear forms\n        flux = upwind ∘ (side⁻(u), side⁺(u), side⁻(c), side⁻(nΓ))\n        l_Γ(v) = ∫(-flux * jump(v))dΓ\n        l_Ω(v) = ∫(u * (c ⋅ ∇ₛ(v)))dΩ ## linear Volumic convective term\n        l(v) = l_Ω(v) + l_Γ(v)\n\n        # Version linear volumic term\n        assemble_linear!(b, l, V)\n        du .= M \\ b\n        @. u.dofValues += Δt * du\n\n        t += Δt\n        progressBar && next!(progress)\n\n        # Output results\n        if ite % (nite ÷ _nout) == 0\n            append_vtk(vtk, u, lim_u, t)\n        end\n    end\nend\n\n# Run\nscalar_circle(; degree = 1, nrot = 5, CFL = 0.1, nθ = 25, isLimiterActive = false)\nvector_circle(; degree = 0, nite = 100, CFL = 1, nθ = 20)\n@time scalar_cylinder(;\n    degree = 1,\n    CFL = 0.1,\n    lz = 10,\n    nθ = 50,\n    nz = 70,\n    ϕ = 0.5 * π / 2,\n    C = 1.0,\n    tmax = 10.0,\n    nout = 100,\n    nitemax = 2000,#Int(1e9),\n    isLimiterActive = false,\n    progressBar = true,\n    meshOrder = 2,\n)\n@time vector_cylinder(;\n    degree = 0,\n    CFL = 0.1,\n    lz = 10,\n    nθ = 50,\n    nz = 70,\n    ϕ_vel = 0.5 * π / 2,\n    C_vel = 1.0,\n    ϕ_u = -0.5 * π / 2,\n    C_u = 1.0,\n    tmax = 10.0,\n    nout = 100,\n    nitemax = 50,#Int(1e9),\n    isLimiterActive = false,\n    progressBar = true,\n)\n@time scalar_torus(;\n    degree = 1,\n    CFL = 0.2, # d=0, CFL=0.4 OK\n    rint = 1.0,\n    rext = 1.5,\n    lc = 0.08,\n    ϕ = 0.5 * π / 2,\n    C = 1.0,\n    tmax = 11.0, # 11s  = 1 turn for rint=1, rext=1.5\n    nout = 100,\n    nitemax = 100000, # d = 4, n = 400 OK,\n    isLimiterActive = false,\n    progressBar = true,\n    meshOrder = 2,\n)\n","category":"page"},{"location":"example/transport_hypersurface/","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":"","category":"page"},{"location":"example/transport_hypersurface/","page":"Transport equation on hypersurfaces","title":"Transport equation on hypersurfaces","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example/poisson_dg/#Poisson-equation-(DG)","page":"Poisson equation (DG)","title":"Poisson equation (DG)","text":"","category":"section"},{"location":"example/poisson_dg/","page":"Poisson equation (DG)","title":"Poisson equation (DG)","text":"module Poisson_DG #hide\nprintln(\"Running poisson DG example...\") #hide\n\n# # Poisson equation (DG)\n# This example is based on a [Gridap tutorial](https://gridap.github.io/Tutorials/stable/pages/t006_dg_discretization/)\n\n# import necessary packages\nusing Bcube\nusing BcubeGmsh\nusing BcubeVTK\nusing LinearAlgebra\nusing SparseArrays\nusing StaticArrays\n\nconst outputpath = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"myout\", \"poisson_dg\")\nisdir(outputpath) || mkpath(outputpath)\nconst degree = 3\nconst degree_quad = 2 * degree + 1\nconst γ = degree * (degree + 1)\nconst n = 4\nconst Lx = 1.0\nconst h = Lx / n\n\nconst uₐ = PhysicalFunction(x -> 3 * x[1] + x[2]^2 + 2 * x[1]^3)\nconst f = PhysicalFunction(x -> -2 - 12 * x[1])\nconst g = uₐ\n\navg(u) = 0.5 * (side⁺(u) + side⁻(u))\n\nfunction main()\n\n    # Build mesh\n    meshParam = (nx = n + 1, ny = n + 1, lx = Lx, ly = Lx, xc = 0.0, yc = 0.0)\n    tmp_path = joinpath(tempdir(), \"tmp.msh\")\n    BcubeGmsh.gen_rectangle_mesh(tmp_path, :quad; meshParam...)\n    mesh = read_mesh(tmp_path)\n\n    # Choose degree and define function space, trial space and test space\n    fs = FunctionSpace(:Lagrange, degree)\n    U = TrialFESpace(fs, mesh, :discontinuous)\n    V = TestFESpace(U)\n\n    # Define volume and boundary measures\n    dΩ = Measure(CellDomain(mesh), degree_quad)\n    dΓ = Measure(InteriorFaceDomain(mesh), degree_quad)\n    dΓb = Measure(BoundaryFaceDomain(mesh), degree_quad)\n    nΓ = get_face_normals(dΓ)\n    nΓb = get_face_normals(dΓb)\n\n    a_Ω(u, v) = ∫(∇(v) ⋅ ∇(u))dΩ\n    l_Ω(v) = ∫(v * f)dΩ\n\n    function a_Γ(u, v)\n        ∫(\n            -jump(v, nΓ) ⋅ avg(∇(u)) - avg(∇(v)) ⋅ jump(u, nΓ) +\n            γ / h * jump(v, nΓ) ⋅ jump(u, nΓ),\n        )dΓ\n    end\n\n    fa_Γb(u, ∇u, v, ∇v, n) = -v * (∇u ⋅ n) - (∇v ⋅ n) * u + (γ / h) * v * u\n    a_Γb(u, v) = ∫(fa_Γb ∘ map(side⁻, (u, ∇(u), v, ∇(v), nΓb)))dΓb\n\n    fl_Γb(v, ∇v, n, g) = -(∇v ⋅ n) * g + (γ / h) * v * g\n    l_Γb(v) = ∫(fl_Γb ∘ map(side⁻, (v, ∇(v), nΓb, g)))dΓb\n\n    a(u, v) = a_Ω(u, v) + a_Γ(u, v) + a_Γb(u, v)\n    l(v) = l_Ω(v) + l_Γb(v)\n\n    sys = Bcube.AffineFESystem(a, l, U, V)\n    uh = Bcube.solve(sys)\n\n    l2(u) = sqrt(sum(Bcube.compute(∫(u ⋅ u)dΩ)))\n    h1(u) = sqrt(sum(Bcube.compute(∫(u ⋅ u + ∇(u) ⋅ ∇(u))dΩ)))\n    e = uₐ - uh\n\n    vars = Dict(\"uh\" => uh, \"u_ref\" => uₐ, \"error\" => e)\n    write_file(joinpath(outputpath, \"output.pvd\"), mesh, U, vars)\n\n    el2 = l2(e)\n    eh1 = h1(e)\n    tol = 1.e-10\n    @show el2, eh1\n    @assert el2 < tol\n    @assert eh1 < tol\nend\n\nmain()\n\nend #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BcubeTutorials","category":"page"},{"location":"#BcubeTutorials","page":"Home","title":"BcubeTutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This website gather several commented tutorials as well as various examples of application of the library Bcube.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bcube is a Julia library providing tools for the spatial discretization of partial differential equation(s) (PDE). The main objective is to provide a set of tools to quickly assemble an algorithm solving partial differential equation(s) efficiently.","category":"page"},{"location":"#Tutorials-vs-examples","page":"Home","title":"Tutorials vs examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tutorials will always follow the Bcube development : they will be kept updated. Examples are more advanced use-cases of Bcube and could be compatible only with a specific version of Bcube (and some other dependencies such as DifferentialEquations.jl).","category":"page"},{"location":"#Run-the-scripts-locally","page":"Home","title":"Run the scripts locally","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All the tutorials can be ran locally with the following steps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, clone the repository","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ git clone https://github.com/bcube-project/BcubeTutorials.jl.git\n$ cd BcubeTutorials.jl/","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, set up the environnement and run the script.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> activate .\n(BcubeTutorials) pkg> instantiate\njulia> include(\"src/tutorial/helmholtz.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Regarding the examples, some of them require additionnal dependencies. Hence each example is associated to a specific environment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> cd(\"src/example/covo\")\njulia> using Pkg\njulia> Pkg.activate(\".\")\njulia> Pkg.add(PackageSpec(url=\"https://github.com/bcube-project/Bcube.jl\"))\njulia> Pkg.instantiate()\njulia> include(\"covo.jl\")","category":"page"},{"location":"#Build-the-documentation","page":"Home","title":"Build the documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To browse the online documentation, simply click on the blue badge at the top of this README. If you would like to build the documentation yourself, for an offline access for instance, you can do it with the following commands.","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ git clone https://github.com/bcube-project/BcubeTutorials.jl.git\n$ cd BcubeTutorials.jl/","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> activate .\n(BcubeTutorials) pkg> instantiate\njulia> include(\"docs/make.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can then browse BcubeTutorials.jl/docs/build/index.html.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ghislain Blanchard, Lokman Bennani and Maxime Bouyges.","category":"page"}]
}
